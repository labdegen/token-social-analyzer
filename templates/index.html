<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASK DEGEN - Social Crypto Dashboard</title>
   <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Lacquer&family=Press+Start+2P&family=Titillium+Web:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700&display=swap" rel="stylesheet">

    <!-- Chart.js for Fear & Greed Dial and Revolutionary Charts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <!-- Plotly for Geographic Heatmaps -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.18.2/plotly.min.js"></script>
  <link rel="stylesheet" href="/static/indexstyle.css" />
  <link rel="script" href="/static/rugcheck.js" />
   
</head>
<body>
    <!-- Fixed Header -->
    <header class="main-header">
        <div class="header-content">
            <a href="#" class="logo"><img style="max-height:60px;" src="https://jeetsvsdegens.com/ask-logo.png"></a>
             <nav class="nav-links">
                <a href="/" class="nav-link">Dashboard</a>
				 <a href="/academy" class="nav-link active">Academy</a>
                <a href="/resources" class="nav-link">Resources</a>
                <a href="/dictionary" class="nav-link">Dictionary</a>
                 <a href="/history" class="nav-link active">History</a>
                <a href="/charts" class="nav-link active">Chart Analysis</a>
            </nav>
        </div>
    </header>


    <div class="dashboard-container">
<div class="news-ticker-container"><span style="background-color:#000; z-index:9; padding-left:10px;">News:</span>
    <div class="news-ticker-content" id="newsTicker">
        <div class="ticker-item">üìà Loading crypto news... Market analysis in progress</div>
    </div>
</div>
        <!-- Enhanced Market Overview Bar with CoinGecko/DexScreener -->
        <div class="market-overview">

            
            <!-- New Enhanced Grid Layout -->
            <div class="market-overview-grid">
                <!-- Condensed Crypto Prices (Left) -->
				<div class="mainleft">
               
					<div class="trending-tokens-section">
    <div class="section-header">
        <span style="font-size: 1.5rem;">üî•</span>
        <div class="section-title">
            Trending Tokens
            <span class="cache-indicator" id="cacheIndicator" style="display: none;">
                Session Cached
            </span>
        </div>
        <button class="refresh-cache-btn" onclick="refreshSessionCache()" title="Refresh Data">
            üîÑ Refresh
        </button>
    </div>
    
    <!-- Tab Navigation -->
    <div class="tab-navigation">
        <button class="tab-btn active" onclick="switchTab('trending')" data-tab="trending">
            üî• Trending Now
        </button>
        <button class="tab-btn" onclick="switchTab('volume')" data-tab="volume">
            üí∞ Volume Spike
        </button>
        <button class="tab-btn" onclick="switchTab('latest')" data-tab="latest">
            ‚ú® Latest Tokens
        </button>
    </div>
    
    <!-- Tab Content -->
    <div class="tab-content active" id="trending">
        <div class="trending-tokens-grid" id="trendingGrid">
            <div class="loading-state">Loading trending tokens...</div>
        </div>
    </div>

    <div class="tab-content" id="volume">
        <div class="trending-tokens-grid" id="volumeGrid">
            <div class="loading-state">Loading high volume tokens...</div>
        </div>
    </div>

    <div class="tab-content" id="latest">
        <div class="trending-tokens-grid" id="latestGrid">
            <div class="loading-state">Loading latest tokens...</div>
        </div>
    </div>
    
    <!-- Session Info Footer -->

</div>
                </div>
     
                
                <!-- Market Intelligence (Right) -->
                <div class="market-intelligence">
                     <div class="crypto-prices" id="cryptoPrices">
                    <!-- Crypto prices will be populated here -->
                </div>
                    <div class="intelligence-section" style="display:none;">
                        <div class="intelligence-section-title">
                            <span>üî•</span>
                            Live Market Insights
                        </div>
                        <div class="market-insights" id="marketInsights">
                            <!-- Market insights will be populated here -->
                        </div>
                    </div>
                          <div class="dial-talk">     <!-- Fear & Greed Dial (Center) -->
               
                    <div class="intelligence-section">
                        <div class="intelligence-section-title">
                            <span>üöÄ</span>
                            Trending Searches
                        </div>
                        <div class="trending-searches" id="trendingSearches">
                            <!-- Trending searches will be populated here -->
                        </div>
					</div> <div class="fear-greed-dial">
                    <div class="dial-title">Fear & Greed Index</div>
                    <div class="dial-container">
                        <canvas id="fearGreedChart" width="120" height="120"></canvas>
                    </div>
                    <div class="dial-value" id="dialValue">72</div>
                    <div class="dial-label" id="dialLabel">Greed</div>
                       <div class="market-sentiment"><br>
                    <span>Sentiment:</span><br>
                    <span id="fearGreedIndex" style="display:none;">Loading...</span>
                    <div class="sentiment-indicator" id="sentimentIndicator">
                        Loading...
                    </div>
                </div>
                </div></div>
					
                </div>
            </div>
        </div>

        <!-- Main Dashboard Grid -->
        <div class="dashboard-grid">
            <!-- Main Content -->
            <div class="main-content">
                <!-- Revolutionary Token Analyzer with Time Window Selector -->
                <div class="token-analyzer">
                    <div class="section-header">
                        <span style="font-size: 1.5rem;">üéØ</span>
                        <div class="section-title">Token Analyzer</div>
                    </div>
                    
                    <div class="analyzer-input">
                        <div class="input-group">
                            <label for="tokenAddress">Solana Token Address:</label>
                            <input 
                                type="text" 
                                id="tokenAddress" 
                                placeholder="e.g. So11111111111111111111111111111111111111112"
                                value=""
                            >
                        </div>
                        <div class="input-group">
                            <label for="timeWindow">Analysis Window:</label>
                            <select id="timeWindow">
                                <option value="1d">üî• 1 Day - Ultra Fresh</option>
                                <option value="3d" selected>‚ö° 3 Days - Optimal</option>
                                <option value="7d">üìä 7 Days - Comprehensive</option>
                            </select>
                        </div>
                        <button class="analyze-btn" onclick="analyzeToken()">
                            üöÄ Analyze
                        </button>
                    </div>

                    <div class="loading-spinner" id="loadingSpinner">
                        <div class="spinner"></div>
                        <div class="loading-text" id="loadingText">üöÄ Analysis starting...</div>
                    </div>

                    <div class="error-message" id="errorMessage"></div>
                </div>

                <!-- DexScreener Chart -->
                <div class="chart-container" id="chartContainer">
                    <iframe id="dexscreenerChart" src=""></iframe>
                </div>
				
				                <!-- Token Profile Section -->
                <div class="token-profile" id="tokenProfile">
                    <div class="token-profile-header">
                        <img class="token-image" id="tokenImage" src="" alt="Token" onerror="this.style.display='none'">
                        <div class="token-info">
                            <h2 id="tokenName">Token Name</h2>
                            <div class="token-contract" id="tokenContract">Contract Address</div>
                        </div>
                    </div>
                    <div class="token-metrics" id="tokenMetrics">
                        <!-- Token metrics will be populated here -->
                    </div>
                </div>

                

                <!-- Results Section -->
                <div class="results-section" id="resultsSection">
                    <!-- Token Age & Risk Intelligence Dashboard -->
                    <div class="token-age-dashboard" id="tokenAgeDashboard" style="display: none;">
                        <div class="section-header">
                            <span style="font-size: 1.5rem;">üï∞Ô∏è</span>
                            <div class="section-title">Token Age & Risk Intelligence</div>
                            <div class="live-data-badge">
                                <div class="live-dot"></div>
                                LAUNCH DETECTION
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 25px;">
                            <div class="age-metric-card">
                                <div class="age-icon">üìÖ</div>
                                <div class="age-value" id="tokenDaysOld">0</div>
                                <div class="age-label">Days Since Launch</div>
                            </div>
                            
                            <div class="age-metric-card">
                                <div class="age-icon">üöÄ</div>
                                <div class="age-value" id="launchPlatform">Unknown</div>
                                <div class="age-label">Platform</div>
                            </div>
                            
                            <div class="age-metric-card">
                                <div class="age-icon">üíß</div>
                                <div class="age-value" id="initialLiquidity">$0</div>
                                <div class="age-label">Liquidity</div>
                            </div>
                            
                            <div class="age-metric-card">
                                <div class="age-icon">‚ö†Ô∏è</div>
                                <div class="age-value" id="riskMultiplier">1.0x</div>
                                <div class="age-label">Risk Multiplier</div>
                            </div>
                        </div>
                    </div>
					
					

                    <!-- Revolutionary Chart.js Visualizations -->
                    <div class="real-social-dashboard" id="realSocialDashboard" >
    <div class="section-header">
        <span style="font-size: 1.5rem;">üî•</span>
        <div class="section-title">Social Data Analysis</div>
        <div class="live-data-badge">
            <div class="live-dot"></div>
            Xai Live Search
        </div>
    </div>
    
    <!-- Charts Grid -->
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
        <!-- 1. Live Tweet Sentiment Chart -->
        <div class="chart-card">
            <h3>üì± Live Tweet Sentiment</h3>
            <canvas id="liveTweetSentimentChart" width="300" height="200"></canvas>
            <div class="chart-value" id="tweetSentimentValue">Analyzing...</div>
        </div>
        
        <!-- 2. Active Accounts Network -->
        <div class="chart-card">
            <h3>üë• Notable Active Accounts</h3>
            <canvas id="activeAccountsChart" width="300" height="200"></canvas>
            <div style="display:none;" class="chart-value" id="activeAccountsValue">0 accounts</div>
        </div>
        
        <!-- 3. Discussion Topics Cloud -->
        <div style="display:none;" class="chart-card">
            <h3>üè∑Ô∏è Discussion Topics</h3>
            <canvas id="discussionTopicsChart" width="300" height="200"></canvas>
            <div style="display:none;" class="chart-value" id="topicsValue">No topics</div>
        </div>
        
        <!-- 4. Platform Distribution -->
        <div style="display:none;" class="chart-card">
            <h3>üìä Platform Sources</h3>
            <canvas id="platformDistributionChart" width="300" height="200"></canvas>
            <div class="chart-value" id="platformValue">No data</div>
        </div>
    </div>
    
    <!-- Data Quality Indicator -->
    <div style="display:none;" id="dataQualityIndicator" style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 12px;">
        <div id="dataQualityText">Analyzing social data quality...</div>
        <div id="dataQualityStats" style="font-size: 0.9rem; color: #b0b7ff; margin-top: 8px;"></div>
  </div>
                        
                        <!-- Sentiment Distribution -->
                        <div style="margin-top: 30px;">
                            <h3 style="color: #10b981; margin-bottom: 15px;">Sentiment Distribution</h3>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                                <div style="background: rgba(16, 185, 129, 0.2); padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 2rem; font-weight: 700; color: #10b981;" id="positiveSentiment">0%</div>
                                    <div style="font-size: 0.9rem; color: #86efac; font-weight: 600;">Bullish</div>
                                </div>
                                <div style="background: rgba(239, 68, 68, 0.2); padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 2rem; font-weight: 700; color: #ef4444;" id="negativeSentiment">0%</div>
                                    <div style="font-size: 0.9rem; color: #fca5a5; font-weight: 600;">Bearish</div>
                                </div>
                                <div style="background: rgba(107, 114, 128, 0.2); padding: 20px; border-radius: 12px; text-align: center;">
                                    <div style="font-size: 2rem; font-weight: 700; color: #6b7280;" id="neutralSentiment">0%</div>
                                    <div style="font-size: 0.9rem; color: #9ca3af; font-weight: 600;">Neutral</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Sentiment Timeline Chart -->
                        <div style="margin-top: 30px;">
                            <h3 style="color: #10b981; margin-bottom: 15px;">Sentiment Timeline</h3>
                            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 16px; padding: 20px; height: 300px;">
                                <canvas id="sentimentTimelineChart" width="400" height="250"></canvas>
                            </div>
                        </div>
                    </div>

                    <!-- Enhanced Search Intelligence Dashboard -->
                    <div class="search-intelligence-dashboard" id="searchIntelligenceDashboard" style="display: none;">
                        <div class="section-header">
                            <span style="font-size: 1.5rem;">üß†</span>
                            <div class="section-title">Search Intelligence</div>
                            <div class="live-data-badge">
                                <div class="live-dot"></div>
                                GOOGLE TRENDS LIVE
                            </div>
                        </div>
                        
                        <div class="search-intel-header">
                            <div class="search-intel-metric">
                                <div class="intel-value" id="currentInterest">19</div>
                                <div class="intel-label">Current Interest</div>
                            </div>
                            
                            <div class="search-intel-metric">
                                <div class="intel-value" id="peakInterest">100</div>
                                <div class="intel-label">Peak Interest</div>
                            </div>
                            
                            <div class="search-intel-metric">
                                <div class="intel-value" id="momentum7d">-14.8%</div>
                                <div class="intel-label">7-Day Momentum</div>
                            </div>
                        </div>
                        
                        <div class="search-intel-charts">
                            <div class="search-trends-chart">
                                <h3 style="color: #10b981; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                                    üìà Search Trends Chart
                                    <span style="font-size: 0.8rem; color: #b0b7ff;">Last 15 Days</span>
                                </h3>
                                <canvas id="searchTrendsChart" width="400" height="250"></canvas>
                            </div>
                            
                            <div class="geo-heatmap-container">
                                <h3 style="color: #10b981; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                                    üåç Geographic Heatmap
                                    <span style="font-size: 0.8rem; color: #b0b7ff;">Search Interest</span>
                                </h3>
                                <div id="geoHeatmap" style="width: 100%; height: 280px;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Social Momentum Dashboard with Visual Metrics -->
                    <div style="display:none;" class="momentum-dashboard">
                        <div class="momentum-header">
                            <div class="momentum-score" id="momentumScore">0</div>
                            <div class="momentum-label">Social Momentum Score</div>
                            <div class="live-data-badge" id="liveDataBadge">
                                <div class="live-dot"></div>
                                üî¥ LIVE DATA
                            </div>
                        </div>
                        <div class="momentum-grid" id="momentumMetrics">
                            <!-- Metrics with visual indicators will be populated here -->
                        </div>
                    </div>

                  <!-- Live Tweets Panel with Accounts to Follow -->
<!-- Replace the Live Tweets Panel section in your HTML with this -->

<!-- Top Accounts Table with Grok API Data -->
<div class="top-accounts-panel">
    <div class="section-header">
        <span style="font-size: 1.5rem;">üìä</span>
        <div class="section-title">Top Accounts Analysis</div>
        <div class="live-data-badge">
            <div class="live-dot"></div>
            GROK LIVE SEARCH
        </div>
    </div>
    
    <!-- Two Column Layout -->
    <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
        <div class="grok-raw-section" id="grok-raw-section" style="display: none;">
    <div class="section-header">
        <h2>ü§ñ Grok Live Analysis</h2>
        <span class="subtitle">Raw AI response from X/Twitter data</span>
    </div>
    
    <div class="grok-raw-container">
        <div class="raw-response-box">
            <pre id="grok-raw-content"></pre>
        </div>
    </div>
</div>

<style>
.grok-raw-section {
    margin: 20px 0;
    background: rgba(138, 120, 255, 0.05);
    border: 1px solid rgba(138, 120, 255, 0.2);
    border-radius: 12px;
    padding: 20px;
}

.section-header {
    margin-bottom: 20px;
}

.section-header h2 {
    color: #8a78ff;
    font-size: 24px;
    margin: 0;
}

.section-header .subtitle {
    color: #666;
    font-size: 14px;
}

.grok-raw-container {
    background: #1a1a2e;
    border-radius: 8px;
    padding: 20px;
    max-height: 500px;
    overflow-y: auto;
}

.raw-response-box pre {
    margin: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
    color: #e0e0e0;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 14px;
    line-height: 1.6;
}

/* Styles for formatted account display */
.grok-accounts-list {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.grok-account-item {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 16px;
    transition: all 0.2s ease;
}

.grok-account-item:hover {
    background: rgba(138, 120, 255, 0.1);
    border-color: rgba(138, 120, 255, 0.3);
}

.account-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
    flex-wrap: wrap;
}

.account-number {
    background: rgba(138, 120, 255, 0.2);
    color: #8a78ff;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
}

.account-name {
    color: #fff;
    font-size: 16px;
    font-weight: 500;
}

.follower-count {
    color: #888;
    font-size: 14px;
    margin-left: auto;
}

.account-activity {
    color: #e0e0e0;
    font-size: 14px;
    line-height: 1.5;
    margin-bottom: 8px;
}

.account-status {
    color: #999;
    font-size: 13px;
    font-style: italic;
}

/* Scrollbar styling */
.grok-raw-container::-webkit-scrollbar {
    width: 8px;
}

.grok-raw-container::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
}

.grok-raw-container::-webkit-scrollbar-thumb {
    background: rgba(138, 120, 255, 0.5);
    border-radius: 4px;
}

.grok-raw-container::-webkit-scrollbar-thumb:hover {
    background: rgba(138, 120, 255, 0.7);
}
</style>


        <!-- Top Accounts Table (2/3 width) -->
        <div>
            <h3 style="color: #ffffff; margin-bottom: 15px; font-size: 1.1rem;">üìà Top Accounts by Engagement</h3>
            <div class="accounts-table-wrapper" id="recentXDiscussionList" style="max-height: 500px; overflow-y: auto;">
                <!-- Accounts table will be populated here -->
                <div class="loading-state" style="text-align: center; padding: 40px; color: #666;">
                    <div style="font-size: 2rem; margin-bottom: 10px;">üìä</div>
                    <p>Analyze a token to see top accounts</p>
                </div>
            </div>
        </div>
        
        <!-- Summary & Who to Follow (1/3 width) -->
        <div>
            <h3 style="color: #ffffff; margin-bottom: 15px; font-size: 1.1rem;">üë• Quick Follow List</h3>
            <div class="accounts-list" id="whoToFollowList" style="max-height: 500px; overflow-y: auto;">
                <!-- Quick follow accounts will be populated here -->
                <div class="loading-state" style="text-align: center; padding: 20px; color: #666;">
                    <div style="font-size: 1.5rem; margin-bottom: 8px;">üë§</div>
                    <p style="font-size: 0.9rem;">Account recommendations will appear here</p>
                </div>
            </div>
            
            <!-- Engagement Summary -->
            <div style="margin-top: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 8px;">
                <h4 style="color: #10b981; margin-bottom: 10px; font-size: 1rem;">üìä Engagement Summary</h4>
                <div id="engagementSummary" style="font-size: 0.9rem; color: #b0b7ff;">
                    <div style="margin-bottom: 5px;">Total Accounts: <span id="totalAccounts">-</span></div>
                    <div style="margin-bottom: 5px;">Avg Engagement: <span id="avgEngagement">-</span></div>
                    <div style="margin-bottom: 5px;">Data Quality: <span id="dataQuality">-</span></div>
                    <div>Source: <span style="color: #fbbf24;">Grok Live Search</span></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Data Source Footer -->
    <div style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px;">
        <p style="color: #667eea; font-size: 0.9rem; margin: 0;">
            <strong>üß† Powered by Grok Live Search API</strong><br>
            Real-time X analysis with engagement metrics and account ranking
        </p>
    </div>
</div>

<style>
/* Enhanced styles for the new accounts table */
.top-accounts-panel {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border-radius: 16px;
    padding: 25px;
    margin: 20px 0;
    border: 1px solid rgba(102, 126, 234, 0.2);
}

.accounts-table-wrapper {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 12px;
    padding: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.accounts-table-container {
    background: transparent;
    padding: 0;
}

.accounts-table-container h4 {
    color: #ffffff;
    margin-bottom: 15px;
    text-align: center;
    font-size: 1.1rem;
}

.table-header {
    display: grid;
    grid-template-columns: 40px 200px 140px 1fr 90px;
    gap: 15px;
    padding: 12px 15px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 8px;
    font-weight: 600;
    color: #ffffff;
    margin-bottom: 10px;
    font-size: 0.9rem;
}

.table-row {
    display: grid;
    grid-template-columns: 40px 200px 140px 1fr 90px;
    gap: 15px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.table-row:hover {
    background: rgba(102, 126, 234, 0.15);
    transform: translateY(-2px);
    border-color: rgba(102, 126, 234, 0.4);
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
}

.col-rank {
    text-align: center;
    font-weight: 700;
    color: #667eea;
    font-size: 1.1rem;
}

.col-account .account-name {
    font-weight: 600;
    color: #ffffff;
    margin-bottom: 4px;
    font-size: 0.95rem;
}

.col-account .account-followers {
    font-size: 0.75rem;
    color: #b0b7ff;
}

.col-engagement .engagement-total {
    font-weight: 600;
    color: #10b981;
    margin-bottom: 4px;
    font-size: 0.95rem;
}

.col-engagement .engagement-breakdown {
    font-size: 0.7rem;
    color: #7dd3fc;
    line-height: 1.2;
}

.col-content .tweet-preview {
    color: #ffffff;
    font-size: 0.85rem;
    margin-bottom: 4px;
    line-height: 1.3;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

.col-content .account-notes {
    font-size: 0.7rem;
    color: #fbbf24;
    font-style: italic;
}

.col-date {
    font-size: 0.8rem;
    color: #9ca3af;
    text-align: center;
    font-weight: 500;
}

.table-footer {
    text-align: center;
    margin-top: 15px;
    padding: 12px;
    color: #667eea;
    font-size: 0.85rem;
    border-top: 1px solid rgba(102, 126, 234, 0.3);
    background: rgba(102, 126, 234, 0.1);
    border-radius: 8px;
}

.no-data-message {
    text-align: center;
    padding: 60px 20px;
    background: rgba(107, 114, 128, 0.1);
    border-radius: 12px;
    color: #9ca3af;
    border: 2px dashed rgba(107, 114, 128, 0.3);
}

.no-data-message h4 {
    color: #f59e0b;
    margin-bottom: 15px;
    font-size: 1.2rem;
}

.no-data-message p {
    margin-bottom: 8px;
    line-height: 1.4;
}

/* Quick follow list styling */
#whoToFollowList .account-item {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

#whoToFollowList .account-item:hover {
    background: rgba(102, 126, 234, 0.1);
    border-color: rgba(102, 126, 234, 0.3);
    transform: translateX(5px);
}

#whoToFollowList .account-username {
    font-weight: 600;
    color: #ffffff;
    margin-bottom: 4px;
}

#whoToFollowList .account-followers {
    font-size: 0.8rem;
    color: #b0b7ff;
    margin-bottom: 6px;
}

#whoToFollowList .account-activity {
    font-size: 0.8rem;
    color: #9ca3af;
    line-height: 1.3;
}

/* Engagement summary styling */
#engagementSummary span {
    font-weight: 600;
    color: #ffffff;
}

/* Responsive design */
@media (max-width: 1024px) {
    .top-accounts-panel > div:first-of-type {
        grid-template-columns: 1fr;
        gap: 15px;
    }
    
    .table-header,
    .table-row {
        grid-template-columns: 30px 150px 100px 1fr 70px;
        gap: 10px;
        padding: 10px;
        font-size: 0.8rem;
    }
}

@media (max-width: 768px) {
    .table-header,
    .table-row {
        grid-template-columns: 1fr;
        gap: 8px;
        text-align: left;
    }
    
    .table-header > div,
    .table-row > div {
        padding: 5px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .table-header > div:last-child,
    .table-row > div:last-child {
        border-bottom: none;
    }
    
    .col-rank::before { content: "Rank: "; color: #667eea; font-weight: normal; }
    .col-account::before { content: "Account: "; color: #667eea; font-weight: normal; }
    .col-engagement::before { content: "Engagement: "; color: #667eea; font-weight: normal; }
    .col-content::before { content: "Content: "; color: #667eea; font-weight: normal; }
    .col-date::before { content: "Date: "; color: #667eea; font-weight: normal; }
}
</style>

                    <!-- Expert Analysis -->
                    <div class="expert-analysis">
                        <div class="section-header">
                            <span style="font-size: 1.5rem;">üéØ</span>
                            <div class="section-title">Expert Analysis</div>
                        </div>
                        <div class="analysis-content" id="expertAnalysis">
                            <!-- Expert analysis will be populated here -->
                        </div>
                    </div>

                  <!-- Meme Coin Psychology Dashboard -->
                    <div class="psychology-dashboard" id="psychologyDashboard" style="display: none;">
                        <div class="section-header">
                            <span style="font-size: 1.5rem;">üß†</span>
                            <div class="section-title">Psychology</div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 25px;">
                            <div class="psychology-card">
                                <div style="height: 120px; margin-bottom: 15px;">
                                    <canvas id="greedGaugeChart" width="120" height="120"></canvas>
                                </div>
                                <div class="psychology-score" id="greedScore">0</div>
                                <div class="psychology-label">Greed Index</div>
                                <div class="psychology-insight" id="greedInsight">Analyzing market greed...</div>
                            </div>
                            <div class="psychology-card">
                                <div style="height: 120px; margin-bottom: 15px;">
                                    <canvas id="euphoriaGaugeChart" width="120" height="120"></canvas>
                                </div>
                                <div class="psychology-score" id="euphoriaMeter">0</div>
                                <div class="psychology-label">Euphoria Meter</div>
                                <div class="psychology-insight" id="euphoriaInsight">Measuring peak excitement...</div>
                            </div>
                            <div class="psychology-card">
                                <div style="height: 120px; margin-bottom: 15px;">
                                    <canvas id="diamondGaugeChart" width="120" height="120"></canvas>
                                </div>
                                <div class="psychology-score" id="diamondHands">0%</div>
                                <div class="psychology-label">Holder Strength</div>
                                <div class="psychology-insight" id="diamondInsight">Holder strength analysis...</div>
                            </div>
                        </div>
                    </div>

                    <!-- Analysis Grid -->
                    <div class="analysis-grid">
                        <!-- Trading Signals -->
                        <div class="analysis-card">
                            <div class="section-header">
                                <span style="font-size: 1.3rem;">üìà</span>
                                <div class="section-title">Trading Signals</div>
                            </div>
                            <div class="card-content" id="tradingSignals">
                                <!-- Trading signals will be populated here -->
                            </div>
                        </div>

                        <!-- Risk Assessment -->
                        <div class="analysis-card">
                            <div class="section-header">
                                <span style="font-size: 1.3rem;">‚ö†Ô∏è</span>
                                <div class="section-title">Risk Assessment</div>
                            </div>
                            <div class="card-content" id="riskAssessment">
                                <!-- Risk assessment will be populated here -->
                            </div>
                        </div>

                        <!-- Market Predictions -->
                        <div class="analysis-card">
                            <div class="section-header">
                                <span style="font-size: 1.3rem;">üîÆ</span>
                                <div class="section-title">Market Predictions</div>
                            </div>
                            <div class="card-content" id="marketPredictions">
                                <!-- Market predictions will be populated here -->
                            </div>
                        </div>
                    </div>

<!-- Safety Analysis Dashboard - Replace the existing one in index.html -->
<div class="safety-analysis-dashboard" id="safetyAnalysisDashboard" style="display: none;">
    <div class="section-header">
        <span style="font-size: 1.5rem;">üß†</span>
        <div class="section-title">Revolutionary Galaxy Brain Safety Analysis</div>
        <div class="live-data-badge">
            <div class="live-dot"></div>
            LIVE GROK INTELLIGENCE
        </div>
    </div>

    <!-- Galaxy Brain Score Summary -->
    <div class="galaxy-brain-summary" id="galaxySafetySummary">
        <div style="display: grid; grid-template-columns: 200px 1fr 200px; gap: 30px; align-items: center;">
            <div class="galaxy-score-display">
                <div class="galaxy-score" id="galaxyBrainScore">0</div>
                <div class="galaxy-score-label">Galaxy Brain Score</div>
            </div>
            
            <div class="safety-analysis-center">
                <div class="severity-level" id="safetyLevel">ANALYZING...</div>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="safetyConfidenceFill"></div>
                </div>
                <p id="safetyConfidenceText">Confidence: 0%</p>
            </div>
            
            <div class="safety-status-indicators">
                <div class="status-indicator" id="authorityStatus">
                    <div class="status-icon">üîê</div>
                    <div class="status-text">Authorities</div>
                    <div class="status-value">Checking...</div>
                </div>
                <div class="status-indicator" id="liquidityStatus">
                    <div class="status-icon">üíß</div>
                    <div class="status-text">Liquidity</div>
                    <div class="status-value">Checking...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Grok Intelligence Panel -->
    <div class="grok-intelligence-panel" id="grokIntelligencePanel" style="display: none;">
        <div class="grok-header">
            <div class="grok-brain-icon">ü§ñ</div>
            <div class="grok-title">Live Grok Community Intelligence</div>
            <div class="grok-verdict" id="grokVerdict">ANALYZING</div>
        </div>
        <div class="grok-content" id="grokAnalysisContent">
            <!-- Grok analysis will be populated here -->
        </div>
    </div>

    <!-- Risk Vectors Grid -->
    <div class="risk-vectors-section">
        <h3 style="color: #ff6b6b; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
            ‚ö†Ô∏è Risk Vectors Analysis
            <span style="font-size: 0.8rem; color: #888;">(Live Detection)</span>
        </h3>
        <div class="risk-vectors-grid" id="riskVectorsGrid">
            <div class="loading-state">Analyzing risk factors...</div>
        </div>
    </div>

    <!-- Advanced Safety Metrics -->
    <div class="advanced-safety-metrics">
        <h3 style="color: #10b981; margin-bottom: 20px;">üìä Advanced Safety Metrics</h3>
        <div class="safety-metrics-grid" id="safetyMetricsGrid">
            <!-- Safety metrics cards will be populated here -->
        </div>
    </div>

    <!-- Safety Charts Section -->
    <div class="safety-charts-section">
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 25px;">
            <!-- Revolutionary Risk Chart -->
            <div class="chart-card">
                <h3>üß† Revolutionary Risk</h3>
                <canvas id="revolutionaryRiskChart" width="300" height="200"></canvas>
                <div class="chart-value" id="revolutionaryRiskValue">Analyzing...</div>
            </div>
            
            <!-- Holder Distribution Chart -->
            <div class="chart-card">
                <h3>üë• Holder Distribution Risk</h3>
                <canvas id="holderDistributionChart" width="300" height="200"></canvas>
                <div class="chart-value" id="holderRiskValue">Analyzing...</div>
            </div>
            
            <!-- Transaction Health Chart -->
            <div class="chart-card">
                <h3>üîÑ Transaction Health Score</h3>
                <canvas id="transactionHealthChart" width="300" height="200"></canvas>
                <div class="chart-value" id="transactionHealthValue">Analyzing...</div>
            </div>
            
            <!-- Bundle Detection Chart -->
            <div class="chart-card">
                <h3>üï∑Ô∏è Bundle Detection Results</h3>
                <canvas id="bundleDetectionChart" width="300" height="200"></canvas>
                <div class="chart-value" id="bundleDetectionValue">Analyzing...</div>
            </div>
        </div>
    </div>

    <!-- Detailed Safety Tabs -->
    <div class="detailed-safety-analysis">
        <div class="analysis-tabs">
            <button class="tab-btn active" onclick="showSafetyTab('holders')">üë• Holders</button>
            <button class="tab-btn" onclick="showSafetyTab('transactions')">üîÑ Transactions</button>
            <button class="tab-btn" onclick="showSafetyTab('bundles')">üï∑Ô∏è Bundles</button>
            <button class="tab-btn" onclick="showSafetyTab('liquidity')">üíß Liquidity</button>
            <button class="tab-btn" onclick="showSafetyTab('authority')">üîê Authority</button>
        </div>
        
        <div class="tab-content active" id="holders-safety-tab">
            <div id="holdersSafetyAnalysis"></div>
        </div>
        
        <div class="tab-content" id="transactions-safety-tab">
            <div id="transactionsSafetyAnalysis"></div>
        </div>
        
        <div class="tab-content" id="bundles-safety-tab">
            <div id="bundlesSafetyAnalysis"></div>
        </div>
        
        <div class="tab-content" id="liquidity-safety-tab">
            <div id="liquiditySafetyAnalysis"></div>
        </div>
        
        <div class="tab-content" id="authority-safety-tab">
            <div id="authoritySafetyAnalysis"></div>
        </div>
    </div>
</div>

<style>
/* Safety Analysis Dashboard Styles */
.safety-analysis-dashboard {
    background: linear-gradient(135deg, rgba(26, 26, 26, 0.95), rgba(26, 26, 46, 0.95));
    backdrop-filter: blur(15px);
    border: 2px solid;
    border-image: linear-gradient(135deg, #6c5ce7, #ff6b6b) 1;
    border-radius: 20px;
    padding: 30px;
    margin: 25px 0;
    position: relative;
    overflow: hidden;
    animation: safetyGlow 4s ease-in-out infinite;
}

@keyframes safetyGlow {
    0%, 100% { box-shadow: 0 0 20px rgba(108, 92, 231, 0.3); }
    50% { box-shadow: 0 0 30px rgba(255, 107, 107, 0.5); }
}

.galaxy-brain-summary {
    background: linear-gradient(135deg, rgba(108, 92, 231, 0.15), rgba(255, 107, 107, 0.15));
    border-radius: 20px;
    padding: 30px;
    margin-bottom: 30px;
    border: 1px solid rgba(108, 92, 231, 0.3);
}

.galaxy-score-display {
    text-align: center;
}

.galaxy-score {
    font-size: 4rem;
    font-weight: 900;
    margin-bottom: 10px;
    text-shadow: 0 0 30px currentColor;
    background: linear-gradient(135deg, #6c5ce7, #ff6b6b, #ffd93d);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-size: 400% 400%;
    animation: scoreGradient 3s ease-in-out infinite;
}

@keyframes scoreGradient {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

.galaxy-score-label {
    color: #b0b7ff;
    font-weight: 600;
    font-size: 1.1rem;
}

.safety-analysis-center {
    text-align: center;
}

.severity-level {
    font-size: 1.8rem;
    font-weight: bold;
    margin-bottom: 15px;
    color: #ffffff;
}

.confidence-bar {
    width: 100%;
    height: 8px;
    background: #333;
    border-radius: 4px;
    margin: 15px 0;
    overflow: hidden;
}

.confidence-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff6b6b, #ffd93d, #51cf66);
    border-radius: 4px;
    transition: width 1s ease;
    width: 0%;
}

.safety-status-indicators {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.status-indicator {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    padding: 15px;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.status-icon {
    font-size: 1.5rem;
    margin-bottom: 8px;
}

.status-text {
    color: #b0b7ff;
    font-size: 0.9rem;
    margin-bottom: 5px;
}

.status-value {
    color: #ffffff;
    font-weight: 600;
    font-size: 0.95rem;
}

.grok-intelligence-panel {
    background: rgba(108, 92, 231, 0.1);
    border: 1px solid #6c5ce7;
    border-radius: 15px;
    padding: 25px;
    margin-bottom: 30px;
}

.grok-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 20px;
}

.grok-brain-icon {
    font-size: 2rem;
    animation: brainPulse 2s ease-in-out infinite;
}

@keyframes brainPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.grok-title {
    font-size: 1.4rem;
    font-weight: bold;
    color: #a29bfe;
    flex: 1;
}

.grok-verdict {
    background: linear-gradient(135deg, #6c5ce7, #a29bfe);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-weight: bold;
    font-size: 0.9rem;
}

.grok-content {
    color: #e0e0e0;
    line-height: 1.6;
}

.risk-vectors-section {
    margin-bottom: 30px;
}

.risk-vectors-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
}

.risk-vector-card {
    background: rgba(26, 26, 26, 0.8);
    border: 1px solid #333;
    border-radius: 15px;
    padding: 20px;
    transition: all 0.3s ease;
}

.risk-vector-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
}

.risk-vector-card.critical {
    border-color: #ff3838;
    background: rgba(255, 56, 56, 0.1);
}

.risk-vector-card.high {
    border-color: #ff6b6b;
    background: rgba(255, 107, 107, 0.1);
}

.risk-vector-card.medium {
    border-color: #ffd93d;
    background: rgba(255, 217, 61, 0.1);
}

.risk-vector-card.low {
    border-color: #51cf66;
    background: rgba(81, 207, 102, 0.1);
}

.advanced-safety-metrics {
    margin-bottom: 30px;
}

.safety-metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
}

.metric-card {
    background: rgba(26, 26, 26, 0.8);
    border: 1px solid #333;
    border-radius: 12px;
    padding: 20px;
    text-align: center;
    transition: all 0.3s ease;
}

.metric-card:hover {
    transform: translateY(-3px);
    border-color: #6c5ce7;
    box-shadow: 0 10px 30px rgba(108, 92, 231, 0.2);
}

.metric-label {
    color: #888;
    font-size: 0.9rem;
    margin-bottom: 10px;
}

.metric-value {
    font-size: 1.8rem;
    font-weight: bold;
    color: #fff;
    margin-bottom: 8px;
}

.metric-subtitle {
    font-size: 0.8rem;
    color: #aaa;
}

.safety-charts-section {
    margin-bottom: 30px;
}

.chart-card {
    background: rgba(26, 26, 26, 0.8);
    border: 1px solid #333;
    border-radius: 15px;
    padding: 20px;
    text-align: center;
    position: relative;
    height: 320px;
}

.chart-card h3 {
    color: #6c5ce7;
    margin-bottom: 15px;
    font-size: 1.1rem;
}

.chart-card canvas {
    max-height: 200px;
    margin-bottom: 10px;
}

.chart-value {
    color: #b0b7ff;
    font-size: 0.9rem;
    font-weight: 600;
}

.detailed-safety-analysis {
    background: rgba(26, 26, 26, 0.6);
    border-radius: 15px;
    padding: 25px;
    border: 1px solid #333;
}

.analysis-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 25px;
    border-bottom: 2px solid #333;
    padding-bottom: 10px;
}

.tab-btn {
    background: transparent;
    border: none;
    color: #888;
    padding: 12px 20px;
    cursor: pointer;
    border-radius: 8px;
    transition: all 0.3s ease;
    font-size: 0.95rem;
    font-weight: 600;
}

.tab-btn:hover {
    color: #b0b7ff;
    background: rgba(108, 92, 231, 0.1);
}

.tab-btn.active {
    color: #ffffff;
    background: rgba(108, 92, 231, 0.2);
    border-bottom: 2px solid #6c5ce7;
}

.tab-content {
    display: none;
    animation: fadeIn 0.3s ease;
}

.tab-content.active {
    display: block;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.loading-state {
    text-align: center;
    color: #888;
    padding: 40px;
    font-style: italic;
}

/* Responsive design */
@media (max-width: 1024px) {
    .galaxy-brain-summary > div {
        grid-template-columns: 1fr;
        gap: 20px;
        text-align: center;
    }
    
    .safety-charts-section > div {
        grid-template-columns: 1fr;
        gap: 20px;
    }
}

@media (max-width: 768px) {
    .safety-analysis-dashboard {
        padding: 20px;
    }
    
    .galaxy-score {
        font-size: 3rem;
    }
    
    .analysis-tabs {
        flex-wrap: wrap;
        gap: 5px;
    }
    
    .tab-btn {
        padding: 8px 12px;
        font-size: 0.85rem;
    }
}
</style>


                </div>
            </div>


        </div>

        <div class="powered-by">
            <p>Powered by <a href="https://x.ai" target="_blank">XAI GROK</a>, <a href="https://coingecko.com" target="_blank">CoinGecko</a> & <a href="https://dexscreener.com" target="_blank">DexScreener</a></p>
            <p style="margin-top: 10px; font-size: 0.9rem;">
                üöÄ Real-time Solana token intelligence with <strong>Revolutionary Chart.js Analytics & Real Google Trends</strong>
            </p>
        </div>
    </div>

    <script>
        let currentAnalysis = null;
        let currentTokenAddress = '';
        let chatHistory = [];
        let currentTab = 'trending';
        let fearGreedChart = null;
        let searchTrendsChart = null;
		        let sentimentTimelineChart = null;
        let greedGaugeChart = null;
        let euphoriaGaugeChart = null;
        let diamondGaugeChart = null;

        // Real Data Chart Implementation (Updated)
        let liveTweetSentimentChart = null;
        let activeAccountsChart = null;
        let discussionTopicsChart = null;
        let platformDistributionChart = null;
        let realTrendsChart = null;

        // Tab click handlers setup (called from main DOMContentLoaded)
        function setupTrendingTokenHandlers() {
            console.log('üöÄ Setting up trending tokens handlers...');
            
            // Set up tab click handlers
            document.addEventListener('click', function(event) {
                if (event.target.closest('.tab-btn')) {
                    const button = event.target.closest('.tab-btn');
                    const category = button.getAttribute('data-tab') || button.getAttribute('onclick')?.match(/'([^']+)'/)?.[1];
                    if (category) {
                        switchToTab(category, button);
                    }
                }
            });
        }

        // Initialize dashboard on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadMarketOverview();
            loadCryptoNews();
            initializeFearGreedChart();
            updateTokenHistoryDisplay(); // Load token history
            disableChatPopup(); // Initialize chat as disabled
            updateHistoryBadge();
            
            // Initialize trending tokens system
            setupTrendingTokenHandlers();
            if (typeof loadCategoryOnce === 'function') {
                loadCategoryOnce('trending');
            } else {
                // Fallback to trending manager if unified cache system not available
                initializeTrendingManager();
            }

            document.addEventListener('click', function(event) {
        const historyWidget = document.querySelector('.floating-history-widget');
        if (historyPopupOpen && historyWidget && !historyWidget.contains(event.target)) {
            toggleHistory();
        }
    });
            
            // Allow Enter key for inputs
            document.getElementById('tokenAddress').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') analyzeToken();
            });
            
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') sendChatMessage();
                });
            }
        });


        function updateCacheStatus() {
    const indicator = document.getElementById('cacheIndicator');
    const sessionInfo = document.getElementById('sessionInfo');
    const lastUpdated = document.getElementById('lastUpdated');
    
    if (sessionTokensCache.loaded) {
        indicator.style.display = 'inline-flex';
        sessionInfo.textContent = 'Data cached for session - no API calls on tab switch';
        lastUpdated.textContent = `Loaded: ${new Date().toLocaleTimeString()}`;
    } else if (sessionTokensCache.loading) {
        sessionInfo.textContent = 'Loading data for session...';
        lastUpdated.textContent = '';
    }
}

        // Fear & Greed Chart Initialization
        function initializeFearGreedChart() {
            const ctx = document.getElementById('fearGreedChart').getContext('2d');
            
            fearGreedChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [72, 28], // Will be updated with real data
                        backgroundColor: [
                            'rgba(16, 185, 129, 0.8)', // Green for current value
                            'rgba(255, 255, 255, 0.1)'  // Gray for remaining
                        ],
                        borderWidth: 0,
                        cutout: '75%'
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    rotation: -90,
                    circumference: 180
                }
            });
        }

        // Market Overview Functions with CoinGecko/DexScreener
        async function loadMarketOverview() {
            try {
                console.log('Loading market overview...'); // Debug log
                const response = await fetch('/market-overview');
                const data = await response.json();
                
                console.log('Market overview response:', data); // Debug log
                
                if (data.success) {
                    updateMarketOverview(data);
                    updateMarketInsights(data.market_insights || []);
                    console.log('Trending searches from API:', data.trending_searches); // Debug log
                    updateTrendingSearches(data.trending_searches || []);
                } else {
                    console.error('Market overview API error:', data);
                    loadFallbackMarketData();
                }
            } catch (error) {
                console.error('Market overview fetch error:', error);
                loadFallbackMarketData();
            }
        }

        function loadFallbackMarketData() {
            // Show fallback data
            updateMarketOverview({
                bitcoin_price: 95000,
                ethereum_price: 3500,
                solana_price: 180,
                market_sentiment: 'Bullish',
                fear_greed_index: 72,
                trending_searches: []
            });
            updateMarketInsights(['üî• Connect to CoinGecko for live insights', 'üìà Market data available', 'üíé Real-time analytics ready']);
            updateTrendingSearches([]);
        }

        function updateMarketOverview(data) {
            // Update Fear & Greed Index
            const fgIndex = data.fear_greed_index || 72;
            document.getElementById('fearGreedIndex').textContent = fgIndex + '/100';
            document.getElementById('dialValue').textContent = fgIndex;
            
            // Update dial label based on value
            const dialLabel = document.getElementById('dialLabel');
            if (fgIndex >= 75) {
                dialLabel.textContent = 'Extreme Greed';
                dialLabel.style.color = '#ef4444';
            } else if (fgIndex >= 55) {
                dialLabel.textContent = 'Greed';
                dialLabel.style.color = '#f59e0b';
            } else if (fgIndex >= 45) {
                dialLabel.textContent = 'Neutral';
                dialLabel.style.color = '#6b7280';
            } else if (fgIndex >= 25) {
                dialLabel.textContent = 'Fear';
                dialLabel.style.color = '#3b82f6';
            } else {
                dialLabel.textContent = 'Extreme Fear';
                dialLabel.style.color = '#10b981';
            }
            
            // Update chart
            if (fearGreedChart) {
                fearGreedChart.data.datasets[0].data = [fgIndex, 100 - fgIndex];
                fearGreedChart.update();
            }
            
            const sentimentEl = document.getElementById('sentimentIndicator');
            sentimentEl.textContent = data.market_sentiment;
            sentimentEl.className = `sentiment-indicator sentiment-${data.market_sentiment.toLowerCase()}`;
            
            // Update condensed crypto prices
            const pricesHtml = `
                <div class="crypto-price-card">
                    <div class="crypto-symbol">BTC</div>
                    <div class="crypto-price">$${data.bitcoin_price?.toLocaleString() || '95,000'}</div>
                    
                </div>
                <div class="crypto-price-card">
                    <div class="crypto-symbol">ETH</div>
                    <div class="crypto-price">$${data.ethereum_price?.toLocaleString() || '3,500'}</div>
                  
                </div>
                <div class="crypto-price-card">
                    <div class="crypto-symbol">SOL</div>
                    <div class="crypto-price">$${data.solana_price?.toLocaleString() || '180'}</div>
                   
                </div>
                <div class="crypto-price-card">
                    <div class="crypto-symbol">Total MC</div>
                    <div class="crypto-price">$${(data.total_market_cap / 1e12)?.toFixed(2) || '2.3'}T</div>
                  
                </div>
            `;
            document.getElementById('cryptoPrices').innerHTML = pricesHtml;
        }

        function updateMarketInsights(insights) {
            const container = document.getElementById('marketInsights');
            let html = '';
            
            insights.slice(0, 12).forEach(insight => {
                html += `<div class="insight-tag">${insight}</div>`;
            });
            
            if (html === '') {
                html = '<div class="insight-tag">Connect to CoinGecko</div><div class="insight-tag">Live market data</div>';
            }
            
            container.innerHTML = html;
        }

        function updateTrendingSearches(searches) {
            console.log('Updating trending searches:', searches); // Debug log
            const container = document.getElementById('trendingSearches');
            if (!container) {
                console.error('Trending searches container not found');
                return;
            }
            
            let html = '';
            
            if (searches && searches.length > 0) {
                searches.slice(0, 6).forEach(search => {
                    const searchName = search.name || search;
                    const marketCapRank = search.market_cap_rank || 999;
                    const trendingUrl = `https://trends.google.com/trends/explore?q=${encodeURIComponent(searchName)}`;
                    
                    html += `
                        <div class="search-item" onclick="window.open('${trendingUrl}', '_blank')">
                            <span class="search-name">${searchName}</span>
                            <span class="search-rank">${marketCapRank < 100 ? '#' + marketCapRank : 'NEW'}</span>
                        </div>
                    `;
                });
            } else {
                // Fallback content if no searches
                html = `
                    <div class="search-item">
                        <span class="search-name">Bitcoin</span>
                        <span class="search-rank">#1</span>
                    </div>
                    <div class="search-item">
                        <span class="search-name">Ethereum</span>
                        <span class="search-rank">#2</span>
                    </div>
                    <div class="search-item">
                        <span class="search-name">Solana</span>
                        <span class="search-rank">#5</span>
                    </div>
                `;
            }
            
            console.log('Setting searches HTML:', html); // Debug log
            container.innerHTML = html;
        }

        // Trending Tokens Functions - FIXED
// Session-based caching for trending tokens
let sessionTokensCache = {
    trending: null,
    volume: null, 
    latest: null,
    loaded: false,
    loading: false
};

// FIXED TRENDING TOKENS IMPLEMENTATION
// Replace the entire trending tokens section in your HTML with this

// Single unified cache system
let unifiedTokensCache = {
    trending: { tokens: [], lastUpdated: null, pricesLoaded: false },
    volume: { tokens: [], lastUpdated: null, pricesLoaded: false },
    latest: { tokens: [], lastUpdated: null, pricesLoaded: false },
    currentTab: 'trending',
    isLoading: false,
    priceCache: new Map() // Cache individual token prices
};

// Main function to load a category once per session
async function loadCategoryOnce(category) {
    const cacheData = unifiedTokensCache[category];
    
    // Check if we already have data and it's less than 30 minutes old
    if (cacheData.tokens.length > 0 && cacheData.lastUpdated) {
        const cacheAge = Date.now() - cacheData.lastUpdated;
        if (cacheAge < 30 * 60 * 1000) { // 30 minutes
            console.log(`‚úÖ Using cached ${category} data (${Math.round(cacheAge/60000)}min old)`);
            displayTokensInGrid(cacheData.tokens, category);
            if (!cacheData.pricesLoaded) {
                loadRealPricesForCategory(category);
            }
            return;
        }
    }
    
    // Prevent multiple simultaneous loads
    if (unifiedTokensCache.isLoading) {
        console.log(`‚è≥ ${category} already loading...`);
        return;
    }
    
    unifiedTokensCache.isLoading = true;
    showLoadingState(category);
    
    try {
        console.log(`üåê Loading ${category} tokens from API...`);
        
        const response = await fetch(`/trending-tokens?category=${category}&refresh=false`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' },
            signal: AbortSignal.timeout(30000) // 30 second timeout
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${await response.text()}`);
        }
        
        const data = await response.json();
        
        if (data.success && data.tokens && data.tokens.length > 0) {
            // Cache the basic token data
            cacheData.tokens = data.tokens;
            cacheData.lastUpdated = Date.now();
            cacheData.pricesLoaded = false;
            
            console.log(`‚úÖ Cached ${data.tokens.length} ${category} tokens`);
            
            // Display immediately with basic data
            displayTokensInGrid(data.tokens, category);
            
            // Load real prices in background
            setTimeout(() => loadRealPricesForCategory(category), 500);
            
        } else {
            throw new Error(data.error || 'No tokens returned');
        }
        
    } catch (error) {
        console.error(`‚ùå Error loading ${category}:`, error.message);
        showErrorState(category, error.message);
        
    } finally {
        unifiedTokensCache.isLoading = false;
    }
}

// Load real price data for tokens in a category
async function loadRealPricesForCategory(category) {
    const cacheData = unifiedTokensCache[category];
    if (!cacheData.tokens.length || cacheData.pricesLoaded) return;
    
    console.log(`üí∞ Loading real prices for ${category} tokens...`);
    
    // Get valid token addresses
    const addresses = cacheData.tokens
        .map(token => token.address)
        .filter(addr => addr && addr.length >= 32 && !addr.startsWith('DEMO'));
    
    if (addresses.length === 0) {
        console.log(`‚ö†Ô∏è No valid addresses for ${category} price loading`);
        cacheData.pricesLoaded = true;
        return;
    }
    
    try {
        // Update loading indicator
        updateCategoryStatus(category, 'Loading prices...');
        
        const response = await fetch('/token-prices', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tokens: addresses.slice(0, 12) }) // Limit to 12 tokens
        });
        
        if (response.ok) {
            const priceData = await response.json();
            
            if (priceData.success) {
                // Update tokens with real price data
                cacheData.tokens = cacheData.tokens.map(token => {
                    const priceInfo = priceData.results[token.address];
                    if (priceInfo && priceInfo.success) {
                        return {
                            ...token,
                            current_price: priceInfo.current_price,
                            price_change_7d: priceInfo.price_change_7d,
                            has_real_price: true
                        };
                    }
                    return token;
                });
                
                cacheData.pricesLoaded = true;
                
                // Re-display with price data if this is the current tab
                if (unifiedTokensCache.currentTab === category) {
                    displayTokensInGrid(cacheData.tokens, category);
                }
                
                console.log(`‚úÖ Loaded real prices for ${category}`);
                updateCategoryStatus(category, 'Ready');
            }
        }
        
    } catch (error) {
        console.error(`‚ùå Price loading error for ${category}:`, error);
        cacheData.pricesLoaded = true; // Mark as attempted
    }
}


function updateAccountsTable(accountTable, socialData) {
    console.log('Updating accounts table with', accountTable.length, 'accounts');
    
    const container = document.getElementById('recentXDiscussionList');
    let tableHtml = '';
    
    if (accountTable.length > 0) {
        tableHtml = `
            <div class="accounts-table-container">
                <h4>üìä Top ${accountTable.length} Accounts by Engagement</h4>
                <div class="accounts-table">
                    <div class="table-header">
                        <div class="col-rank">#</div>
                        <div class="col-account">Account</div>
                        <div class="col-engagement">Engagement</div>
                        <div class="col-content">Latest Activity</div>
                        <div class="col-date">Date</div>
                    </div>
        `;
        
        accountTable.forEach(account => {
            const engagementDisplay = formatEngagementCount(account.total_engagement);
            const accountUsername = account.account.replace('@', '');
            const followerDisplay = formatFollowerDisplay(account.follower_count);
            const tweetPreview = truncateText(account.tweet_content, 100);
            const notesPreview = truncateText(account.notes, 80);
            
            tableHtml += `
                <div class="table-row" onclick="openAccountLink('${accountUsername}')">
                    <div class="col-rank">${account.rank}</div>
                    <div class="col-account">
                        <div class="account-name">${account.account}</div>
                        <div class="account-followers">${followerDisplay}</div>
                    </div>
                    <div class="col-engagement">
                        <div class="engagement-total">${engagementDisplay}</div>
                        <div class="engagement-breakdown">
                            ${formatEngagementBreakdown(account)}
                        </div>
                    </div>
                    <div class="col-content">
                        <div class="tweet-preview">${tweetPreview}</div>
                        <div class="account-notes">${notesPreview}</div>
                    </div>
                    <div class="col-date">${formatDate(account.date_posted)}</div>
                </div>
            `;
        });
        
        tableHtml += `
                </div>
                <div class="table-footer">
                    <p>üß† Powered by Grok Live Search API ‚Ä¢ Real-time X engagement analysis</p>
                    <p style="margin-top: 5px; font-size: 0.8rem; color: #7dd3fc;">
                        Data Quality: ${socialData.data_quality} ‚Ä¢ Found ${socialData.total_accounts_found} accounts
                    </p>
                </div>
            </div>
        `;
    } else {
        tableHtml = createNoDataMessage(socialData);
    }
    
    container.innerHTML = tableHtml;
}

function createNoDataMessage(socialData) {
    const isApiError = socialData.data_quality === 'no_data';
    const hasLimitedData = socialData.data_quality === 'limited';
    
    return `
        <div class="no-data-message">
            <div style="font-size: 3rem; margin-bottom: 15px;">
                ${isApiError ? 'üîç' : hasLimitedData ? 'üìä' : 'üí≠'}
            </div>
            <h4>${isApiError ? 'No Discussion Found' : hasLimitedData ? 'Limited Data Available' : 'Searching...'}</h4>
            <p>${isApiError ? 'Grok API found no significant discussions about this token in the selected timeframe.' : 
                hasLimitedData ? 'Found some mentions but limited engagement data available.' : 
                'Analyzing social media activity...'}</p>
            <p style="color: #fbbf24; margin-top: 10px;">
                üí° Try analyzing a more popular token or extend the time window
            </p>
            ${isApiError ? `
                <div style="margin-top: 20px; padding: 15px; background: rgba(245, 158, 11, 0.1); border-radius: 8px;">
                    <strong>Suggestions:</strong><br>
                    ‚Ä¢ Check if token symbol is correct<br>
                    ‚Ä¢ Try a trending token like BONK or WIF<br>
                    ‚Ä¢ Extend analysis to 7 days<br>
                    ‚Ä¢ Verify Grok API configuration
                </div>
            ` : ''}
        </div>
    `;
}


// Switch to a tab (no API calls, just display cached data)
function switchToTab(category, buttonElement) {
    if (unifiedTokensCache.currentTab === category) return;
    
    console.log(`üîÑ Switching to ${category} tab`);
    unifiedTokensCache.currentTab = category;
    
    // Update active tab button
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    buttonElement.classList.add('active');
    
    // Update tab content visibility
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
    const contentElement = document.getElementById(category);
    if (contentElement) {
        contentElement.classList.add('active');
    }
    
    // Load category data if not already loaded
    loadCategoryOnce(category);
}

// Display tokens in the grid
function displayTokensInGrid(tokens, category) {
    const gridElement = document.getElementById(`${category}Grid`);
    if (!gridElement) return;
    
    if (!tokens || tokens.length === 0) {
        gridElement.innerHTML = '<div class="error-state">No tokens available</div>';
        return;
    }
    
    let tokensHtml = '';
    
    tokens.slice(0, 12).forEach(token => {
        const isClickable = token.address && token.address.length >= 32 && 
                           !token.address.startsWith('DEMO');
        
        const clickHandler = isClickable ? `onclick="loadTokenAnalysis('${token.address}')"` : '';
        const cursorStyle = isClickable ? 'cursor: pointer;' : 'cursor: default; opacity: 0.7;';
        
        // Simple price display only
        let priceDisplay = 'Loading...';
        
        if (token.has_real_price && token.current_price !== undefined) {
            priceDisplay = token.current_price > 0 ? `$${token.current_price.toFixed(8)}` : 'N/A';
        } else {
            priceDisplay = formatMarketCap(token.volume) + ' vol';
        }
        
        tokensHtml += `
            <div class="trending-token ${category}" ${clickHandler} style="${cursorStyle}">
                <div class="trending-symbol">${token.symbol}</div>
                <div class="trending-price">${priceDisplay}</div>
            
                ${!isClickable ? '<div style="font-size: 0.6rem; color: #888; margin-top: 5px;">View only</div>' : ''}
            </div>
        `;
    });
    
    gridElement.innerHTML = tokensHtml;
}

// Utility functions
function showLoadingState(category) {
    const gridElement = document.getElementById(`${category}Grid`);
    if (gridElement) {
        gridElement.innerHTML = `
            <div class="loading-state">
                <div class="spinner"></div>
                <div>Loading ${category} tokens...</div>
            </div>
        `;
    }
}

function showErrorState(category, errorMessage) {
    const gridElement = document.getElementById(`${category}Grid`);
    if (gridElement) {
        gridElement.innerHTML = `
            <div class="error-state">
                <div>‚ö†Ô∏è Error loading ${category} tokens</div>
                <div style="font-size: 0.8rem; margin-top: 10px;">${errorMessage}</div>
                <button onclick="refreshCategory('${category}')" style="margin-top: 10px; padding: 8px 16px; border: 1px solid #667eea; background: transparent; color: #667eea; border-radius: 4px; cursor: pointer;">
                    üîÑ Retry
                </button>
            </div>
        `;
    }
}

function updateCategoryStatus(category, status) {
    const tabButton = document.querySelector(`[data-tab="${category}"]`);
    if (tabButton) {
        const statusSpan = tabButton.querySelector('.tab-status') || 
                          tabButton.querySelector('.cache-indicator');
        if (statusSpan) {
            statusSpan.textContent = status;
        }
    }
}

function refreshCategory(category) {
    console.log(`üîÑ Refreshing ${category}...`);
    
    // Clear cache
    unifiedTokensCache[category] = { tokens: [], lastUpdated: null, pricesLoaded: false };
    
    // Reload
    loadCategoryOnce(category);
}

function formatMarketCap(value) {
    if (value >= 1e9) return `$${(value / 1e9).toFixed(1)}B`;
    if (value >= 1e6) return `$${(value / 1e6).toFixed(1)}M`;
    if (value >= 1e3) return `$${(value / 1e3).toFixed(0)}K`;
    if (value > 0) return `$${value.toFixed(0)}`;
    return 'N/A';
}

// Global functions for compatibility
function switchTab(tabName) {
    const button = document.querySelector(`[data-tab="${tabName}"]`) || 
                   document.querySelector(`[onclick*="${tabName}"]`);
    if (button) {
        switchToTab(tabName, button);
    }
}

function refreshSessionCache() {
    const currentTab = unifiedTokensCache.currentTab;
    refreshCategory(currentTab);
}

  

        function loadTokenAnalysis(address) {
            if (!address) return;
            
            // Set the token address in the input field
            document.getElementById('tokenAddress').value = address;
            
            // Scroll to analyzer
            document.querySelector('.token-analyzer').scrollIntoView({ behavior: 'smooth' });
            
            // Auto-analyze after a short delay
            setTimeout(() => {
                analyzeToken();
            }, 500);
        }

        // Toggle Functions
       // Token History Management
let tokenHistory = JSON.parse(sessionStorage.getItem('tokenHistory')) || [];

function addToTokenHistory(tokenData) {
    // Remove existing entry for this token
    tokenHistory = tokenHistory.filter(item => item.token_address !== tokenData.token_address);
    
    // Add new entry at the beginning
    const historyItem = {
        token_address: tokenData.token_address,
        token_symbol: tokenData.token_symbol,
        token_name: tokenData.token_name,
        price_usd: tokenData.price_usd,
        price_change_24h: tokenData.price_change_24h,
        market_cap: tokenData.market_cap,
        timestamp: new Date().toISOString(),
        analysis_data: tokenData
    };
    
    tokenHistory.unshift(historyItem);
    
    // Keep only last 20 tokens
    if (tokenHistory.length > 20) {
        tokenHistory = tokenHistory.slice(0, 20);
    }
    
    // Save to session storage
    sessionStorage.setItem('tokenHistory', JSON.stringify(tokenHistory));
    
    // Update display if popup is open, otherwise just update badge
    if (historyPopupOpen) {
        updateTokenHistoryDisplay();
    } else {
        updateHistoryBadge();
    }
}

function updateTokenHistoryDisplay() {
    const historyContainer = document.getElementById('historyPopupContent');
    const subtitle = document.getElementById('historySubtitle');
    const countBadge = document.getElementById('historyCountBadge');
    const trigger = document.getElementById('historyTrigger');
    
    // Update count badge and subtitle
    const count = tokenHistory.length;
    updateHistoryBadge();
    
    if (!historyContainer) return;
    
    if (tokenHistory.length === 0) {
        historyContainer.innerHTML = `
            <div class="popup-history-empty">
                <div class="empty-icon">üìà</div>
                <h3>No Token History</h3>
                <p>Analyze tokens to build your history and quickly access previous analyses.</p>
            </div>
        `;
        return;
    }
    
    let historyHtml = '';
    tokenHistory.forEach(item => {
        const timeAgo = getRelativeTime(item.timestamp);
        const changeClass = item.price_change_24h >= 0 ? 'positive' : 'negative';
        const changeSign = item.price_change_24h >= 0 ? '+' : '';
        
        historyHtml += `
            <div class="popup-history-item" onclick="loadFromHistory('${item.token_address}')">
                <div class="popup-history-symbol">
                    ${item.token_symbol}
                    <span style="font-size: 12px; color: #888;">#${tokenHistory.indexOf(item) + 1}</span>
                </div>
                <div class="popup-history-name">${item.token_name}</div>
                <div class="popup-history-meta">
                    <span class="popup-history-price">$${(item.price_usd || 0).toFixed(8)}</span>
                    <span class="popup-history-change ${changeClass}">
                        ${changeSign}${(item.price_change_24h || 0).toFixed(2)}%
                    </span>
                </div>
                <div class="popup-history-meta">
                    <span style="font-size: 11px; color: #888;">MC: ${formatNumber(item.market_cap || 0)}</span>
                    <span style="font-size: 11px; color: #888;">Vol: ${formatNumber(item.volume_24h || 0)}</span>
                </div>
                <div class="popup-history-time">${timeAgo}</div>
            </div>
        `;
    });
    
    historyContainer.innerHTML = historyHtml;
}

function loadFromHistory(tokenAddress) {
    const historyItem = tokenHistory.find(item => item.token_address === tokenAddress);
    if (!historyItem) return;
    
    // Set the token address in the input
    document.getElementById('tokenAddress').value = tokenAddress;
    
    // Load cached analysis if available
    if (historyItem.analysis_data) {
        console.log('Loading from cached analysis data...');
        currentAnalysis = historyItem.analysis_data;
        currentTokenAddress = tokenAddress;
        
        // Display results immediately from cache
        try {
            displayResults(historyItem.analysis_data);
            showChart(tokenAddress);
            enableChatWithContext();
        } catch (error) {
            console.error('Error loading from cache:', error);
            // Fall back to fresh analysis
            analyzeToken();
        }
    } else {
        // Run fresh analysis
        analyzeToken();
    }
    
    // Scroll to results
    setTimeout(() => {
        document.getElementById('tokenAddress').scrollIntoView({ behavior: 'smooth' });
    }, 300);
}

function clearTokenHistory() {
    if (confirm('Clear all token history?')) {
        tokenHistory = [];
        sessionStorage.removeItem('tokenHistory');
        updateTokenHistoryDisplay();
    }
}

function getRelativeTime(timestamp) {
    const now = new Date();
    const past = new Date(timestamp);
    const diffMs = now - past;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    return `${Math.floor(diffHours / 24)}d ago`;
}

function formatNumber(num) {
    if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
    if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
    return num.toString();
}

// Floating Chat Widget Functions
let chatPopupOpen = false;
let chatPopupHistory = [];

function toggleChat() {
    const chatPopup = document.getElementById('chatPopup');
    const chatTrigger = document.getElementById('chatTrigger');
    
    chatPopupOpen = !chatPopupOpen;
    
    if (chatPopupOpen) {
        chatPopup.classList.add('active');
        chatTrigger.style.transform = 'scale(0.9)';
        // Focus input if enabled
        const input = document.getElementById('chatInputPopup');
        if (!input.disabled) {
            setTimeout(() => input.focus(), 300);
        }
    } else {
        chatPopup.classList.remove('active');
        chatTrigger.style.transform = 'scale(1)';
    }
}

function enableChatPopup() {
    const chatInput = document.getElementById('chatInputPopup');
    const chatSend = document.getElementById('chatSendPopup');
    const chatStatus = document.getElementById('chatStatus');
    
    chatInput.disabled = false;
    chatInput.placeholder = `Ask about ${currentAnalysis?.token_symbol || 'the analyzed token'}...`;
    chatSend.disabled = false;
    chatStatus.textContent = 'Ready';
    chatStatus.style.color = '#10b981';
    
    // Add pulsing effect to trigger when ready
    const trigger = document.getElementById('chatTrigger');
    trigger.classList.add('ready');
    
    // Allow Enter key
    chatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !chatInput.disabled) {
            sendChatMessagePopup();
        }
    });
}

function disableChatPopup() {
    const chatInput = document.getElementById('chatInputPopup');
    const chatSend = document.getElementById('chatSendPopup');
    const chatStatus = document.getElementById('chatStatus');
    
    chatInput.disabled = true;
    chatInput.placeholder = 'Analyze a token first...';
    chatSend.disabled = true;
    chatStatus.textContent = 'Analyze a token first';
    chatStatus.style.color = '#f59e0b';
}

async function sendChatMessagePopup() {
    const chatInput = document.getElementById('chatInputPopup');
    const message = chatInput.value.trim();
    
    if (!message || !currentTokenAddress) return;

    addChatMessagePopup(message, 'user');
    chatInput.value = '';
    
    // Show typing indicator
    showTypingIndicator();

    try {
        const response = await fetch('/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                token_address: currentTokenAddress,
                message: message,
                history: chatPopupHistory
            })
        });

        const data = await response.json();
        
        hideTypingIndicator();
        
        if (data.response) {
            addChatMessagePopup(data.response, 'assistant');
        } else {
            addChatMessagePopup('Sorry, I encountered an error. Please try again.', 'assistant');
        }
        
    } catch (error) {
        console.error('Chat error:', error);
        hideTypingIndicator();
        addChatMessagePopup('Connection error. Please try again.', 'assistant');
    }
}

function addChatMessagePopup(message, sender) {
    const chatMessages = document.getElementById('chatPopupMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender}`;
    messageDiv.textContent = message;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    chatPopupHistory.push({
        role: sender === 'user' ? 'user' : 'assistant',
        content: message
    });
    
    if (chatPopupHistory.length > 8) {
        chatPopupHistory = chatPopupHistory.slice(-8);
    }
}

function showTypingIndicator() {
    const chatMessages = document.getElementById('chatPopupMessages');
    const typingDiv = document.createElement('div');
    typingDiv.className = 'chat-message assistant typing-indicator';
    typingDiv.innerHTML = '<div class="typing-dots"><span></span><span></span><span></span></div>';
    typingDiv.id = 'typingIndicator';
    
    chatMessages.appendChild(typingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function hideTypingIndicator() {
    const indicator = document.getElementById('typingIndicator');
    if (indicator) {
        indicator.remove();
    }
}

        // Crypto News Functions with RSS
// Crypto News Functions with RSS - Now for ticker
async function loadCryptoNews() {
    try {
        const response = await fetch('/crypto-news');
        const data = await response.json();
        
        if (data.success && data.articles && data.articles.length > 0) {
            displayCryptoNewsTicker(data.articles);
        } else {
            // Fallback ticker content if API fails
            displayFallbackTicker();
        }
    } catch (error) {
        console.error('Crypto news error:', error);
        displayFallbackTicker();
    }
}

function displayFallbackTicker() {
    const tickerContainer = document.getElementById('newsTicker');
    
    // Stop animation temporarily
    tickerContainer.style.animation = 'none';
    
    const fallbackNews = [
        "üìà Bitcoin holds above $95,000 as institutional interest remains strong",
        "‚ö° Ethereum sees increased Layer 2 adoption with record transaction volumes", 
        "üöÄ Solana ecosystem continues growth with new DeFi protocols launching",
        "üíé Crypto market cap maintains $2.3 trillion as sentiment stays bullish",
        "üìä Major exchanges report surge in altcoin trading volumes",
        "üî• DeFi protocols reach new milestone in total value locked",
        "‚öñÔ∏è Regulatory clarity drives institutional crypto adoption forward",
        "üéØ Meme coin sector attracts renewed retail investor attention"
    ];
    
    let tickerHtml = '';
    fallbackNews.forEach(headline => {
        tickerHtml += `<div class="ticker-item" title="Market Update">${headline}</div>`;
    });
    
    // Duplicate for seamless loop
    tickerContainer.innerHTML = tickerHtml + tickerHtml;
    
    // Restart animation
    tickerContainer.offsetHeight; // Trigger reflow
    tickerContainer.style.animation = 'scroll-ticker 180s linear infinite';
}

function displayCryptoNewsTicker(articles) {
    let tickerHtml = '';
    
    // Just use the articles as-is, no duplication
    let articlesToShow = articles.slice(0, 8);
    
    if (articlesToShow.length < 8) {
        const fallbackArticles = [
            { headline: "Bitcoin maintains strong position as institutional adoption continues", url: "#", summary: "BTC holding steady" },
            { headline: "Ethereum Layer 2 solutions see record transaction volumes", url: "#", summary: "L2 scaling success" },
            { headline: "Solana ecosystem tokens rally on increased developer activity", url: "#", summary: "SOL ecosystem growth" },
            { headline: "DeFi total value locked reaches new quarterly high", url: "#", summary: "DeFi growth continues" }
        ];
        
        while (articlesToShow.length < 8) {
            articlesToShow.push(fallbackArticles[articlesToShow.length % fallbackArticles.length]);
        }
    }
    
    articlesToShow.forEach(article => {
        tickerHtml += `<div class="ticker-item" onclick="window.open('${article.url}', '_blank')" title="${article.summary}">${article.headline}</div>`;
    });
    
    // NO DUPLICATION - just set the content
    document.getElementById('newsTicker').innerHTML = tickerHtml;
}

        // Enhanced Token Analysis Functions with Time Window
       async function analyzeToken() {
    const tokenAddress = document.getElementById('tokenAddress').value.trim();
    const timeWindow = document.getElementById('timeWindow').value;
    
    if (!tokenAddress) {
        showError('Please enter a token address');
        return;
    }

    if (tokenAddress.length < 32 || tokenAddress.length > 44) {
        showError('Invalid Solana token address format');
        return;
    }

    currentTokenAddress = tokenAddress;
    chatHistory = [];

    showLoading();
    hideError();
    hideResults();
    showChart(tokenAddress);

    try {
        const response = await fetch('/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                token_address: tokenAddress,
                time_window: timeWindow
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // Improved SSE parsing with better error handling
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let eventCount = 0;

        console.log('Starting SSE stream parsing...');

        while (true) {
            const { done, value } = await reader.read();
            
            if (done) {
                console.log('SSE stream completed, processed', eventCount, 'events');
                break;
            }

            // Decode the chunk
            const chunk = decoder.decode(value, { stream: true });
            buffer += chunk;
            
            // Process complete SSE events (ending with \n\n)
            let eventEndIndex;
            while ((eventEndIndex = buffer.indexOf('\n\n')) !== -1) {
                const eventData = buffer.slice(0, eventEndIndex);
                buffer = buffer.slice(eventEndIndex + 2);
                
                // Process the complete event
                const lines = eventData.split('\n');
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonString = line.substring(6).trim();
                        if (jsonString) {
                            try {
                                console.log('Parsing SSE message, length:', jsonString.length);
                                
                                // Enhanced JSON parsing with validation
                                const data = JSON.parse(jsonString);
                                
                                // Validate the parsed data structure
                                if (data && typeof data === 'object' && data.type) {
                                    console.log('Successfully parsed SSE event:', data.type);
                                    handleStreamMessage(data);
                                    eventCount++;
                                } else {
                                    console.warn('Invalid SSE event structure:', data);
                                }
                                
                            } catch (parseError) {
                                console.error('JSON parse error:', parseError);
                                console.error('Failed JSON string length:', jsonString.length);
                                console.error('First 200 chars:', jsonString.substring(0, 200));
                                console.error('Last 200 chars:', jsonString.substring(Math.max(0, jsonString.length - 200)));
                                
                                // Try to recover by checking if it's a partial message
                                if (jsonString.includes('"type"') && !jsonString.trim().endsWith('}')) {
                                    console.warn('Partial JSON detected, adding back to buffer');
                                    buffer = 'data: ' + jsonString + '\n' + buffer;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            // Safety check: if buffer gets too large, something is wrong
            if (buffer.length > 1000000) { // 1MB limit
                console.error('Buffer overflow detected, clearing buffer');
                console.error('Buffer content preview:', buffer.substring(0, 500));
                buffer = '';
                throw new Error('SSE buffer overflow - response too large');
            }
        }
        
        // Process any remaining data in buffer
        if (buffer.trim()) {
            console.warn('Remaining buffer content:', buffer.substring(0, 200));
        }
        
    } catch (error) {
        console.error('Analysis error:', error);
        hideLoading();
        showError('Analysis failed: ' + error.message);
    }
}

function handleStreamMessage(data) {
    try {
        console.log('Handling stream message type:', data.type);
        
        if (data.type === 'progress') {
            let message = data.message || 'Processing...';
            
            // Add special handling for real sentiment timeline
            if (data.stage === 'real_sentiment_timeline') {
                message = 'üìä Building Real Sentiment Timeline - No fake data!';
            }
            
            updateLoadingText(message);
        } else if (data.type === 'complete') {
            console.log('Analysis complete, displaying results');
            currentAnalysis = data;
            hideLoading();
            
            // ADD THIS LINE HERE:
            displayGrokRawResponse(data);
            
            setTimeout(() => {
                try {
                    displayResults(data);
                } catch (displayError) {
                    console.error('Error displaying results:', displayError);
                    showError('Error displaying results: ' + displayError.message);
                }
            }, 100);
            
        } else if (data.type === 'error') {
            console.error('Server error:', data.error);
            hideLoading();
            showError('Analysis error: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        console.error('Error handling stream message:', error);
        hideLoading();
        showError('Error processing response: ' + error.message);
    }
}

// Function to display Grok raw response
function displayGrokRawResponse(data) {
    console.log('displayGrokRawResponse called with:', data);
    
    // Try multiple paths to find the raw response
    const rawResponse = data.raw_grok_response || 
                       data.real_social_data?.raw_grok_response ||
                       data.realSocialData?.raw_grok_response;
    
    const section = document.getElementById('grok-raw-section');
    const contentElement = document.getElementById('grok-raw-content');
    
    if (!section || !contentElement) {
        console.error('Grok display elements not found');
        return;
    }
    
    if (rawResponse && rawResponse !== "No response from Grok API") {
        // Show the section
        section.style.display = 'block';
        
        try {
            // Try to parse as JSON
            const jsonData = JSON.parse(rawResponse);
            console.log('Parsed Grok JSON:', jsonData);
            contentElement.innerHTML = formatGrokJsonResponse(jsonData);
        } catch (e) {
            // If not JSON, display as formatted text
            console.log('Displaying as text:', rawResponse);
            const formattedContent = rawResponse
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>')
                .replace(/@(\w+)/g, '<a href="https://x.com/$1" target="_blank" class="account-handle">@$1</a>');
            contentElement.innerHTML = formattedContent;
        }
    } else {
        console.log('No valid Grok response found');
        section.style.display = 'block';
        contentElement.innerHTML = '<div class="grok-error">No Grok data available</div>';
    }
}

function formatGrokJsonResponse(jsonData) {
    if (Array.isArray(jsonData)) {
        let html = '<div class="grok-accounts-list">';
        
        jsonData.forEach((account, index) => {
            const handle = account.handle || account.username || 'Unknown';
            const cleanHandle = handle.startsWith('@') ? handle.substring(1) : handle;
            const followerCount = account.follower_count || account.followers || 'Unknown followers';
            const activity = account.recent_activity || account.recent_tweet || 'No activity data';
            
            html += `
                <div class="grok-account-item">
                    <div class="account-header">
                        <span class="account-number">#${index + 1}</span>
                        <a href="https://x.com/${cleanHandle}" target="_blank" class="account-handle">@${cleanHandle}</a>
                        <span class="follower-count">${followerCount}</span>
                    </div>
                    <div class="account-activity">
                        <strong>Recent Activity:</strong> ${escapeHtml(activity)}
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        return html;
    } else {
        // Format as pretty JSON if not an array
        return '<pre>' + JSON.stringify(jsonData, null, 2) + '</pre>';
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

        function showChart(tokenAddress) {
            const chartContainer = document.getElementById('chartContainer');
            const iframe = document.getElementById('dexscreenerChart');
            
            iframe.src = `https://dexscreener.com/solana/${tokenAddress}?embed=1&loadChartSettings=0&chartLeftToolbar=0&chartTheme=dark&theme=dark&chartStyle=1&chartType=usd&interval=15`;
            chartContainer.style.display = 'block';
            chartContainer.classList.add('fade-in');
        }

        // Updated displayResults function for real data
        function displayResults(data) {
            console.log('Starting to display results with real data...');
            
            try {

                console.log('Updating token profile...');
                updateTokenProfile(data);
                
                // Add safety dashboard
                console.log('Updating safety dashboard...');
                updateSafetyDashboard(data);
                
                // Show token profile
                console.log('Updating token profile...');
                updateTokenProfile(data);
                
                // Show Token Age Dashboard
                console.log('Updating token age dashboard...');
                updateTokenAgeDashboard(data);
                
                // Show Real Social Data Charts
                console.log('Updating real social data charts...');
                updateRealSocialCharts(data);
                
                // Show Real Google Trends
                console.log('Updating search intelligence...');
                updateSearchIntelligence(data);
                
                // Show results section
                console.log('Showing results section...');
                document.getElementById('resultsSection').style.display = 'block';
                document.getElementById('resultsSection').classList.add('fade-in');

                // Update all sections with individual error handling
                try {
                    console.log('Updating momentum dashboard...');
                    updateMomentumDashboard(data);
                } catch (e) {
                    console.error('Error updating momentum dashboard:', e);
                }
                
                try {
                    console.log('Updating tweets section...');
                    updateTweetsSection(data);
                } catch (e) {
                    console.error('Error updating tweets section:', e);
                }
                
                try {
                    console.log('Updating expert analysis...');
                    updateExpertAnalysis(data);
                } catch (e) {
                    console.error('Error updating expert analysis:', e);
                }
                
                try {
                    console.log('Updating analysis cards...');
                    updateAnalysisCards(data);
                } catch (e) {
                    console.error('Error updating analysis cards:', e);
                }
                
                try {
                    console.log('Updating psychology dashboard...');
                    updatePsychologyDashboard(data);
                } catch (e) {
                    console.error('Error updating psychology dashboard:', e);
                }
                
                try {
                    console.log('Updating sentiment timeline...');
                    updateSentimentTimeline(data);
                } catch (e) {
                    console.error('Error updating sentiment timeline:', e);
                }
                

                try {
                    addToTokenHistory(data);
                } catch (e) {
                    console.error('Error adding to history:', e);
                }

                try {
                    console.log('Enabling chat...');
                    enableChatWithContext();
                    enableChatPopup(); // Enable popup chat
                } catch (e) {
                    console.error('Error enabling chat:', e);
                }

                // Scroll to results
                console.log('Scrolling to results...');
                setTimeout(() => {
                    document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
                }, 300);
                
                console.log('Results display completed successfully');
                
            } catch (error) {
                console.error('Error in displayResults:', error);
                showError('Error displaying results: ' + error.message);
            }
        }

        // New function to update Token Age Dashboard
        function updateTokenAgeDashboard(data) {
            const tokenAge = data.token_age || {};
            
            document.getElementById('tokenDaysOld').textContent = tokenAge.days_old || 'Unknown';
            document.getElementById('launchPlatform').textContent = tokenAge.launch_platform || 'Unknown';
            document.getElementById('initialLiquidity').textContent = '$' + (tokenAge.initial_liquidity || 0).toLocaleString();
            document.getElementById('riskMultiplier').textContent = (tokenAge.risk_multiplier || 1.0).toFixed(1) + 'x';
            
            // Color code risk multiplier
            const riskElement = document.getElementById('riskMultiplier');
            const risk = tokenAge.risk_multiplier || 1.0;
            if (risk >= 2.0) {
                riskElement.style.color = '#ef4444'; // Red for high risk
            } else if (risk >= 1.5) {
                riskElement.style.color = '#f59e0b'; // Orange for medium risk
            } else {
                riskElement.style.color = '#10b981'; // Green for low risk
            }
            
            document.getElementById('tokenAgeDashboard').style.display = 'block';
        }
		
		
   function updateRealSocialCharts(data) {
    const realSocialData = data.real_social_data || {};
    const sentimentMetrics = data.sentiment_metrics || {};
    
    console.log('Real social data received:', realSocialData);
    console.log('Sentiment metrics received:', sentimentMetrics);
    
    // Update sentiment distribution immediately with real data
    updateSentimentDistribution(sentimentMetrics, data);
    
    console.log('Real social data received:', realSocialData);
    
    if (!realSocialData.has_real_data) {
        // Show no data state
        document.getElementById('realSocialDashboard').style.display = 'block';
        updateDataQualityIndicator({
            quality: 'no_data',
            message: 'No significant social activity found for this token',
            tweets: 0,
            accounts: 0
        });
        initNoDataCharts();
        return;
    }
    
    // Fixed: ensure arrays exist before passing to chart functions
    const tweets = realSocialData.tweets || [];
    const accounts = realSocialData.accounts || realSocialData.active_accounts || [];
    const topics = realSocialData.discussion_topics || [];
    const platforms = realSocialData.platform_distribution || {};
    
    // Initialize all 4 real data charts with safe data
    initLiveTweetSentimentChart(tweets);
    initActiveAccountsChart(accounts);
    initDiscussionTopicsChart(topics);
    initPlatformDistributionChart(platforms);
    
    // Update data quality indicator
    updateDataQualityIndicator({
        quality: realSocialData.data_quality,
        message: 'Real social data successfully collected',
        tweets: realSocialData.total_tweets_found || 0,
        accounts: realSocialData.total_accounts_found || 0
    });
    
    document.getElementById('realSocialDashboard').style.display = 'block';
}

        // 1. Live Tweet Sentiment Chart - Real tweets color-coded by sentiment
        function initLiveTweetSentimentChart(tweets) {
            const ctx = document.getElementById('liveTweetSentimentChart').getContext('2d');
            
            if (liveTweetSentimentChart) liveTweetSentimentChart.destroy();
            
            if (!tweets || tweets.length === 0) {
                // Show "No Data" chart
                liveTweetSentimentChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No Tweets Found'],
                        datasets: [{
                            label: 'No Data',
                            data: [1],
                            backgroundColor: 'rgba(107, 114, 128, 0.5)',
                            borderColor: '#6b7280',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { display: false },
                            x: { grid: { color: 'rgba(255, 255, 255, 0.1)' }, ticks: { color: '#b0b7ff', font: { size: 10 } } }
                        }
                    }
                });
                document.getElementById('tweetSentimentValue').textContent = 'No tweets found';
                return;
            }
            
            // Process real tweets
            const labels = tweets.map((tweet, index) => `@${tweet.username}`);
            const sentimentColors = tweets.map(tweet => {
                switch(tweet.sentiment) {
                    case 'bullish': return 'rgba(16, 185, 129, 0.8)';
                    case 'bearish': return 'rgba(239, 68, 68, 0.8)';
                    default: return 'rgba(107, 114, 128, 0.8)';
                }
            });
            const engagementData = tweets.map(() => 1); // Bar height = 1 for visualization
            
            liveTweetSentimentChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Tweet Sentiment',
                        data: engagementData,
                        backgroundColor: sentimentColors,
                        borderColor: sentimentColors.map(color => color.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y', // Horizontal bars
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (context) => tweets[context[0].dataIndex].username,
                                label: (context) => {
                                    const tweet = tweets[context.dataIndex];
                                    return [`Sentiment: ${tweet.sentiment}`, `"${tweet.content.substring(0, 100)}..."`];
                                }
                            }
                        }
                    },
                    scales: {
                        x: { display: false },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#b0b7ff', font: { size: 9 } }
                        }
                    }
                }
            });
            
            // Count sentiments
            const bullishCount = tweets.filter(t => t.sentiment === 'bullish').length;
            const bearishCount = tweets.filter(t => t.sentiment === 'bearish').length;
            const neutralCount = tweets.filter(t => t.sentiment === 'neutral').length;
            
            document.getElementById('tweetSentimentValue').textContent = 
                `${tweets.length} tweets: ${bullishCount} üü¢ ${bearishCount} üî¥ ${neutralCount} ‚ö™`;
        }

        // 2. Active Accounts Chart - Bubble chart of real accounts
        function initActiveAccountsChart(accounts) {
            const ctx = document.getElementById('activeAccountsChart').getContext('2d');
            
            if (activeAccountsChart) activeAccountsChart.destroy();
            
            if (!accounts || accounts.length === 0) {
                // Show "No Data" chart
                activeAccountsChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'No Accounts Found',
                            data: [{x: 0, y: 0}],
                            backgroundColor: 'rgba(107, 114, 128, 0.5)',
                            borderColor: '#6b7280',
                            pointRadius: 20
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: { display: false },
                            y: { display: false }
                        }
                    }
                });
                document.getElementById('activeAccountsValue').textContent = 'No accounts found';
                return;
            }
            
            // Process real accounts
            const bubbleData = accounts.map((account, index) => {
                // Extract follower count for bubble size
                const followerMatch = account.followers.match(/(\d+)K?/);
                const followerCount = followerMatch ? parseInt(followerMatch[1]) : 10;
                const radius = Math.max(5, Math.min(30, followerCount / 5)); // Scale bubble size
                
                return {
                    x: Math.random() * 100, // Random positioning for network effect
                    y: Math.random() * 100,
                    r: radius,
                    username: account.username,
                    followers: account.followers
                };
            });
            
            activeAccountsChart = new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'Active Accounts',
                        data: bubbleData,
                        backgroundColor: 'rgba(102, 126, 234, 0.6)',
                        borderColor: '#667eea',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: (context) => `@${context[0].raw.username}`,
                                label: (context) => context.raw.followers
                            }
                        }
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    }
                }
            });
            
            document.getElementById('activeAccountsValue').textContent = `${accounts.length} active accounts`;
        }

        // 3. Discussion Topics Chart - Bar chart of real keywords
        function initDiscussionTopicsChart(topics) {
            const ctx = document.getElementById('discussionTopicsChart').getContext('2d');
            
            if (discussionTopicsChart) discussionTopicsChart.destroy();
            
            if (!topics || topics.length === 0) {
                // Show "No Data" chart
                discussionTopicsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No Topics Found'],
                        datasets: [{
                            label: 'No Data',
                            data: [1],
                            backgroundColor: 'rgba(107, 114, 128, 0.5)',
                            borderColor: '#6b7280',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { display: false },
                            x: { grid: { color: 'rgba(255, 255, 255, 0.1)' }, ticks: { color: '#b0b7ff', font: { size: 10 } } }
                        }
                    }
                });
                document.getElementById('topicsValue').textContent = 'No topics found';
                return;
            }
            
            // Use top 8 topics
            const topTopics = topics.slice(0, 8);
            const labels = topTopics.map(topic => topic.keyword);
            const data = topTopics.map(topic => topic.mentions);
            
            discussionTopicsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Mentions',
                        data: data,
                        backgroundColor: 'rgba(16, 185, 129, 0.6)',
                        borderColor: '#10b981',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#b0b7ff', font: { size: 9 } }
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#b0b7ff', 
                                font: { size: 8 },
                                maxRotation: 45
                            }
                        }
                    }
                }
            });
            
            document.getElementById('topicsValue').textContent = `${topics.length} discussion topics`;
        }

        // 4. Platform Distribution Chart - Pie chart of real platform sources
        function initPlatformDistributionChart(platformData) {
            const ctx = document.getElementById('platformDistributionChart').getContext('2d');
            
            if (platformDistributionChart) platformDistributionChart.destroy();
            
            // Filter platforms with data
            const platforms = Object.entries(platformData).filter(([platform, count]) => count > 0);
            
            if (platforms.length === 0) {
                // Show "No Data" chart
                platformDistributionChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['No Platform Data'],
                        datasets: [{
                            data: [1],
                            backgroundColor: ['rgba(107, 114, 128, 0.5)'],
                            borderColor: ['#6b7280'],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } }
                    }
                });
                document.getElementById('platformValue').textContent = 'No platform data';
                return;
            }
            
            const labels = platforms.map(([platform]) => platform.charAt(0).toUpperCase() + platform.slice(1));
            const data = platforms.map(([, count]) => count);
            const colors = [
                'rgba(29, 161, 242, 0.8)', // Twitter blue
                'rgba(0, 136, 204, 0.8)',  // Telegram blue
                'rgba(255, 69, 0, 0.8)',   // Reddit orange
                'rgba(114, 137, 218, 0.8)' // Discord purple
            ];
            
            platformDistributionChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors.slice(0, platforms.length),
                        borderColor: colors.slice(0, platforms.length).map(color => color.replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: { color: '#b0b7ff', font: { size: 9 } }
                        }
                    }
                }
            });
            
            const totalMentions = data.reduce((sum, count) => sum + count, 0);
            document.getElementById('platformValue').textContent = `${totalMentions} total mentions`;
        }

        function initNoDataCharts() {
            // Initialize empty charts when no data is available
            initLiveTweetSentimentChart([]);
            initActiveAccountsChart([]);
            initDiscussionTopicsChart([]);
            initPlatformDistributionChart({});
        }

       // Psychology Dashboard Functions
function updatePsychologyDashboard(data) {
    console.log('Updating psychology dashboard with data:', data.psychology_metrics);
    
    // Get psychology metrics from backend
    const psychologyMetrics = data.psychology_metrics || {};
    const greedIndex = psychologyMetrics.greed_index || {};
    const euphoriaMeter = psychologyMetrics.euphoria_meter || {};
    const diamondHands = psychologyMetrics.diamond_hands || {};
    
    // Update greed index
    const greedScore = greedIndex.score || 50;
    document.getElementById('greedScore').textContent = greedScore;
    document.getElementById('greedInsight').textContent = greedIndex.description || "Analyzing market greed...";
    
    // Update euphoria meter  
    const euphoriaScore = euphoriaMeter.score || 50;
    document.getElementById('euphoriaMeter').textContent = euphoriaScore;
    document.getElementById('euphoriaInsight').textContent = euphoriaMeter.level || "Measuring peak excitement...";
    
    // Update diamond hands
    const diamondScore = diamondHands.score || 45;
    document.getElementById('diamondHands').textContent = diamondScore + '%';
    document.getElementById('diamondInsight').textContent = diamondHands.level || "Holder strength analysis...";
    
    // Create gauge charts with proper colors
 createGaugeChart('greedGaugeChart',   greedScore);     // green fill, black track
createGaugeChart('euphoriaGaugeChart', euphoriaScore); // green fill, black track
createGaugeChart('diamondGaugeChart',  diamondScore);
    
    // Show the psychology dashboard
    document.getElementById('psychologyDashboard').style.display = 'block';
    
    console.log(`Psychology updated: Greed=${greedScore} (${greedIndex.level}), Euphoria=${euphoriaScore} (${euphoriaMeter.level}), Diamond=${diamondScore}% (${diamondHands.level})`);
}

        function createGaugeChart(canvasId, value, fillColor = '#10b981', trackColor = '#000000') {

  const ctx = document.getElementById(canvasId).getContext('2d');

  if (ctx._chart) ctx._chart.destroy();        // tear down an old instance

  ctx._chart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      datasets: [{
        data: [value, 100 - value],
        backgroundColor: [fillColor, trackColor],
        borderWidth: 0
      }]
    },
    options: {
      rotation: -90,         // ‚Üê degrees
      circumference: 180,    // ‚Üê degrees
      cutout: '75%',
      plugins: {
        legend: { display: false },
        tooltip: { enabled: false }
      },
      responsive: true,
      maintainAspectRatio: false
    }
  });
}

        function calculateGreedIndex(metrics, priceChange) {
            const sentiment = metrics.sentiment_positive || 0;
            const momentum = Math.abs(metrics.momentum_change || 0);
            const priceImpact = Math.min(Math.abs(priceChange) / 50, 1) * 30;
            
            return Math.min(100, Math.round((sentiment * 0.4) + (momentum * 0.3) + priceImpact));
        }

        function calculateEuphoria(metrics, tokenAge) {
            const ageMultiplier = (tokenAge.hours_old || 24) < 24 ? 1.5 : 1;
            const hype = metrics.hype_score || 50;
            const viral = metrics.viral_potential || 50;
            
            return Math.min(100, Math.round(((hype + viral) / 2) * ageMultiplier));
        }

function calculateDiamondHands(metrics, volume, analysisText = '') {
            // First try to count actual "diamond hands" mentions
            const diamondHandsMentions = countDiamondHandsMentions(analysisText);
            
            if (diamondHandsMentions > 0) {
                // Base score on actual mentions (scale to 0-100)
                return Math.min(100, diamondHandsMentions * 20);
            }
            
            // Fallback to calculated metric
            const sentiment = metrics.sentiment_positive || 0;
            const coordination = metrics.coordination_detected ? -20 : 0;
            const volumeStability = volume > 1000000 ? 20 : 0;
            const hodlStrength = metrics.hodl_strength || 0; // if available from backend
            
            return Math.max(0, Math.min(100, Math.round(sentiment * 0.5 + volumeStability + coordination + hodlStrength * 0.3)));
        }

        function countDiamondHandsMentions(text) {
            if (!text) return 0;
            
            const patterns = [
                /diamond\s*hands?/gi,
                /üíé\s*üôå/g,
                /üíé.*hands?/gi,
                /hodl/gi,
                /hold.*long/gi
            ];
            
            let totalMentions = 0;
            patterns.forEach(pattern => {
                const matches = text.match(pattern);
                if (matches) totalMentions += matches.length;
            });
            
            console.log(`Found ${totalMentions} diamond hands mentions`);
            return totalMentions;
        }

        function getGreedInsight(score) {
            if (score >= 80) return "Extreme greed detected - potential top signal";
            if (score >= 60) return "High greed - market getting heated";
            if (score >= 40) return "Moderate greed - healthy momentum";
            return "Low greed - potential accumulation phase";
        }

        function getEuphoriaInsight(score) {
            if (score >= 80) return "Peak euphoria - caution advised";
            if (score >= 60) return "Building excitement - monitor closely";
            if (score >= 40) return "Growing interest - early stage";
            return "Minimal euphoria - under the radar";
        }

        function getDiamondInsight(score) {
            if (score >= 70) return "Strong holder base detected";
            if (score >= 50) return "Decent holder conviction";
            if (score >= 30) return "Mixed holder sentiment";
            return "Weak hands present - volatility expected";
        }

// Sentiment Timeline Chart
       function updateSentimentTimeline(data) {
    console.log('Updating sentiment timeline with real data:', data.sentiment_timeline);
    
    const sentimentTimeline = data.sentiment_timeline || {};
    const tokenAge = data.token_age || {};
    
    // Check if we have real timeline data
    if (sentimentTimeline.has_real_data) {
        createRealSentimentTimelineChart(sentimentTimeline, data.time_window, tokenAge);
    } else {
        // Fallback to current method for backwards compatibility
        createFallbackTimelineChart(data);
    }
}

function createRealSentimentTimelineChart(sentimentTimeline, timeWindow, tokenAge) {
    const ctx = document.getElementById('sentimentTimelineChart').getContext('2d');
    
    if (sentimentTimelineChart) sentimentTimelineChart.destroy();
    
    const timelineData = sentimentTimeline.timeline_data || [];
    const effectiveDays = sentimentTimeline.effective_days || 0;
    const isSinglePoint = sentimentTimeline.single_point || false;
    const isAgeAdjusted = sentimentTimeline.token_age_adjusted || false;
    
    // Show age adjustment warning if needed
    if (isAgeAdjusted) {
        showTimelineAdjustmentNotice(timeWindow, effectiveDays, tokenAge.days_old);
    }
    
    if (isSinglePoint || timelineData.length === 1) {
        createSinglePointChart(ctx, timelineData[0], tokenAge);
    } else if (timelineData.length === 2) {
        createTwoPointChart(ctx, timelineData, timeWindow);
    } else {
        createMultiPointChart(ctx, timelineData, timeWindow);
    }
}

function createSinglePointChart(ctx, dataPoint, tokenAge) {
    console.log('Creating single point chart for new token');
    
    // For very new tokens, show a single point with current sentiment
    const data = dataPoint || { bullish: 0, bearish: 0, neutral: 0, total_mentions: 0 };
    
    sentimentTimelineChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: ['Bullish', 'Bearish', 'Neutral'],
            datasets: [{
                data: [data.bullish, data.bearish, data.neutral],
                backgroundColor: [
                    'rgba(16, 185, 129, 0.8)',  // Green for bullish
                    'rgba(239, 68, 68, 0.8)',   // Red for bearish
                    'rgba(107, 114, 128, 0.8)'  // Gray for neutral
                ],
                borderColor: [
                    '#10b981',
                    '#ef4444', 
                    '#6b7280'
                ],
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    position: 'bottom',
                    labels: {
                        color: '#b0b7ff',
                        font: { size: 11 }
                    }
                },
                title: {
                    display: true,
                    text: `Current Sentiment (${data.total_mentions} mentions)`,
                    color: '#ffffff',
                    font: { size: 14, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.label}: ${context.parsed}%`;
                        }
                    }
                }
            }
        }
    });
    
    // Add explanation text below chart
    const chartContainer = ctx.canvas.parentElement;
    if (!chartContainer.querySelector('.timeline-explanation')) {
        const explanation = document.createElement('div');
        explanation.className = 'timeline-explanation';
        explanation.style.cssText = `
            text-align: center; 
            margin-top: 15px; 
            padding: 10px; 
            background: rgba(245, 158, 11, 0.1); 
            border-radius: 8px; 
            color: #f59e0b; 
            font-size: 0.85rem;
        `;
        explanation.innerHTML = `
            <strong>‚ö° Fresh Launch!</strong><br>
            Token is only ${tokenAge.days_old || 0} days old - showing current sentiment snapshot
        `;
        chartContainer.appendChild(explanation);
    }
}

function createTwoPointChart(ctx, timelineData, timeWindow) {
    console.log('Creating two-point comparison chart');
    
    const [earlierPoint, laterPoint] = timelineData;
    
    sentimentTimelineChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Bullish', 'Bearish', 'Neutral'],
            datasets: [
                {
                    label: earlierPoint.label,
                    data: [earlierPoint.bullish, earlierPoint.bearish, earlierPoint.neutral],
                    backgroundColor: [
                        'rgba(16, 185, 129, 0.5)',
                        'rgba(239, 68, 68, 0.5)',
                        'rgba(107, 114, 128, 0.5)'
                    ],
                    borderColor: ['#10b981', '#ef4444', '#6b7280'],
                    borderWidth: 1
                },
                {
                    label: laterPoint.label,
                    data: [laterPoint.bullish, laterPoint.bearish, laterPoint.neutral],
                    backgroundColor: [
                        'rgba(16, 185, 129, 0.8)',
                        'rgba(239, 68, 68, 0.8)',
                        'rgba(107, 114, 128, 0.8)'
                    ],
                    borderColor: ['#10b981', '#ef4444', '#6b7280'],
                    borderWidth: 2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: { color: '#b0b7ff', font: { size: 11 } }
                },
                title: {
                    display: true,
                    text: `Sentiment Change (${timeWindow})`,
                    color: '#ffffff',
                    font: { size: 14, weight: 'bold' }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { 
                        color: '#b0b7ff', 
                        font: { size: 10 },
                        callback: function(value) { return value + '%'; }
                    }
                },
                x: {
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { color: '#b0b7ff', font: { size: 10 } }
                }
            }
        }
    });
}

function createMultiPointChart(ctx, timelineData, timeWindow) {
    console.log('Creating multi-point timeline chart with', timelineData.length, 'data points');
    
    const labels = timelineData.map(d => d.label);
    const bullishData = timelineData.map(d => d.bullish);
    const bearishData = timelineData.map(d => d.bearish);
    const neutralData = timelineData.map(d => d.neutral);
    
    sentimentTimelineChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Bullish',
                    data: bullishData,
                    borderColor: '#10b981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    tension: 0.4,
                    fill: true,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6
                },
                {
                    label: 'Bearish',
                    data: bearishData,
                    borderColor: '#ef4444',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    tension: 0.4,
                    fill: true,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6
                },
                {
                    label: 'Neutral',
                    data: neutralData,
                    borderColor: '#6b7280',
                    backgroundColor: 'rgba(107, 114, 128, 0.1)',
                    tension: 0.4,
                    fill: true,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: { color: '#b0b7ff', font: { size: 12 } }
                },
                title: {
                    display: true,
                    text: `Real Sentiment Timeline (${timeWindow})`,
                    color: '#ffffff',
                    font: { size: 14, weight: 'bold' }
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            const dataPoint = timelineData[context[0].dataIndex];
                            return `${dataPoint.label} (${dataPoint.total_mentions} mentions)`;
                        },
                        label: function(context) {
                            return `${context.dataset.label}: ${context.parsed.y}%`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { 
                        color: '#b0b7ff', 
                        font: { size: 10 },
                        callback: function(value) { return value + '%'; }
                    }
                },
                x: {
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { 
                        color: '#b0b7ff', 
                        font: { size: 9 },
                        maxRotation: 45
                    }
                }
            }
        }
    });
}

function showTimelineAdjustmentNotice(requestedWindow, effectiveDays, tokenAgeDays) {
    // Show a notice that the timeline was adjusted due to token age
    const chartContainer = document.getElementById('sentimentTimelineChart').parentElement;
    
    // Remove existing notice
    const existingNotice = chartContainer.querySelector('.timeline-adjustment-notice');
    if (existingNotice) {
        existingNotice.remove();
    }
    
    const notice = document.createElement('div');
    notice.className = 'timeline-adjustment-notice';
    notice.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(245, 158, 11, 0.9);
        color: #000;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        z-index: 10;
        max-width: 200px;
    `;
    
    notice.innerHTML = `
        ‚ö†Ô∏è Timeline Adjusted<br>
        Requested: ${requestedWindow}<br>
        Actual: ${effectiveDays}d (token age: ${tokenAgeDays}d)
    `;
    
    // Position relative to allow absolute positioning
    chartContainer.style.position = 'relative';
    chartContainer.appendChild(notice);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notice.parentElement) {
            notice.remove();
        }
    }, 5000);
}

function createFallbackTimelineChart(data) {
    // Keep existing fallback method for backward compatibility
    const socialMetrics = data.social_metrics || {};
    const sentimentMetrics = data.sentiment_metrics || {};
    const timeSeriesData = socialMetrics.time_series_data || [];
    
    // Get current sentiment for baseline
    const currentSentiment = {
        bullish: sentimentMetrics.bullish_percentage || socialMetrics.sentiment_positive || 0,
        bearish: sentimentMetrics.bearish_percentage || socialMetrics.sentiment_negative || 0,
        neutral: sentimentMetrics.neutral_percentage || socialMetrics.sentiment_neutral || 0
    };
    
    if (timeSeriesData.length === 0) {
        // Generate sample data based on current sentiment
        const sampleData = generateSampleTimelineData(data.time_window || '3d', currentSentiment);
        createSentimentTimelineChart(sampleData);
    } else {
        createSentimentTimelineChart(timeSeriesData);
    }
}

// Keep the existing functions for backward compatibility
function generateSampleTimelineData(timeWindow, currentSentiment = null) {
    const periods = timeWindow === '1d' ? 6 : timeWindow === '3d' ? 12 : 21;
    const data = [];
    
    // Use current sentiment as baseline or defaults
    const baseBullish = currentSentiment ? currentSentiment.bullish : 50;
    const baseBearish = currentSentiment ? currentSentiment.bearish : 30;
    const baseNeutral = currentSentiment ? currentSentiment.neutral : 20;
    
    for (let i = 0; i < periods; i++) {
        const date = new Date();
        date.setHours(date.getHours() - (periods - i) * (timeWindow === '1d' ? 4 : timeWindow === '3d' ? 6 : 8));
        
        // Create realistic variation around the current sentiment
        const variation = 10; // +/- 10% variation
        const bullish = Math.max(0, Math.min(100, baseBullish + (Math.random() - 0.5) * variation));
        const bearish = Math.max(0, Math.min(100, baseBearish + (Math.random() - 0.5) * variation));
        const neutral = Math.max(0, 100 - bullish - bearish);
        
        data.push({
            date: date.toLocaleDateString(),
            bullish: bullish,
            bearish: bearish,
            neutral: neutral
        });
    }
    
    return data;
}

function createSentimentTimelineChart(timeSeriesData) {
    const ctx = document.getElementById('sentimentTimelineChart').getContext('2d');
    
    if (sentimentTimelineChart) sentimentTimelineChart.destroy();
    
    const labels = timeSeriesData.map(d => d.date);
    const bullishData = timeSeriesData.map(d => d.bullish);
    const bearishData = timeSeriesData.map(d => d.bearish);
    const neutralData = timeSeriesData.map(d => d.neutral);
    
    sentimentTimelineChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Bullish',
                    data: bullishData,
                    borderColor: '#10b981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    tension: 0.4,
                    fill: true
                },
                {
                    label: 'Bearish',
                    data: bearishData,
                    borderColor: '#ef4444',
                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                    tension: 0.4,
                    fill: true
                },
                {
                    label: 'Neutral',
                    data: neutralData,
                    borderColor: '#6b7280',
                    backgroundColor: 'rgba(107, 114, 128, 0.1)',
                    tension: 0.4,
                    fill: true
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: { color: '#b0b7ff', font: { size: 12 } }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { 
                        color: '#b0b7ff', 
                        font: { size: 10 },
                        callback: function(value) { return value + '%'; }
                    }
                },
                x: {
                    grid: { color: 'rgba(255, 255, 255, 0.1)' },
                    ticks: { 
                        color: '#b0b7ff', 
                        font: { size: 9 },
                        maxRotation: 45
                    }
                }
            }
        }
    });
}

            // Update Sentiment Distribution
        function updateSentimentDistribution(sentimentMetrics, data) {
            // Try multiple data sources for sentiment
            let bullish = 0, bearish = 0, neutral = 0;
            
            // First try sentiment_metrics
            if (sentimentMetrics.bullish_percentage) {
                bullish = sentimentMetrics.bullish_percentage;
                bearish = sentimentMetrics.bearish_percentage || 0;
                neutral = sentimentMetrics.neutral_percentage || 0;
            }
            // Then try social_metrics
            else if (data.social_metrics) {
                bullish = data.social_metrics.sentiment_positive || 0;
                bearish = data.social_metrics.sentiment_negative || 0; 
                neutral = data.social_metrics.sentiment_neutral || 0;
            }
            // Finally try to extract from expert analysis text
            else if (data.expert_analysis) {
                const extracted = extractSentimentFromText(data.expert_analysis);
                bullish = extracted.bullish;
                bearish = extracted.bearish;
                neutral = extracted.neutral;
            }
            
            // Normalize to 100% if needed
            const total = bullish + bearish + neutral;
            if (total > 0 && total !== 100) {
                bullish = (bullish / total) * 100;
                bearish = (bearish / total) * 100;
                neutral = (neutral / total) * 100;
            }
            
            // Update the display
            document.getElementById('positiveSentiment').textContent = `${bullish.toFixed(1)}%`;
            document.getElementById('negativeSentiment').textContent = `${bearish.toFixed(1)}%`;
            document.getElementById('neutralSentiment').textContent = `${neutral.toFixed(1)}%`;
            
            console.log(`Updated sentiment: ${bullish.toFixed(1)}% bullish, ${bearish.toFixed(1)}% bearish, ${neutral.toFixed(1)}% neutral`);
        }

        function extractSentimentFromText(analysisText) {
            // Extract sentiment percentages from expert analysis text
            const bullishMatch = analysisText.match(/bullish:?\s*(\d+(?:\.\d+)?)%/i);
            const bearishMatch = analysisText.match(/bearish:?\s*(\d+(?:\.\d+)?)%/i);
            const neutralMatch = analysisText.match(/neutral:?\s*(\d+(?:\.\d+)?)%/i);
            
            const bullish = bullishMatch ? parseFloat(bullishMatch[1]) : 0;
            const bearish = bearishMatch ? parseFloat(bearishMatch[1]) : 0;
            const neutral = neutralMatch ? parseFloat(neutralMatch[1]) : 0;
            
            console.log('Extracted from text:', { bullish, bearish, neutral });
            
            return { bullish, bearish, neutral };
        }

        // Add this new function after updateRealSocialCharts
        function updateDataQualityIndicator(qualityData) {
            const indicator = document.getElementById('dataQualityIndicator');
            const textEl = document.getElementById('dataQualityText');
            const statsEl = document.getElementById('dataQualityStats');
            
            switch(qualityData.quality) {
                case 'real':
                    indicator.style.background = 'rgba(16, 185, 129, 0.2)';
                    textEl.textContent = '‚úÖ High Quality Real Data';
                    textEl.style.color = '#10b981';
                    break;
                case 'limited':
                    indicator.style.background = 'rgba(245, 158, 11, 0.2)';
                    textEl.textContent = 'üü° Limited Real Data';
                    textEl.style.color = '#f59e0b';
                    break;
                case 'no_data':
                    indicator.style.background = 'rgba(107, 114, 128, 0.2)';
                    textEl.textContent = '‚ö™ No Social Activity Found';
                    textEl.style.color = '#6b7280';
                    break;
            }
            
            statsEl.textContent = `${qualityData.tweets} real tweets ‚Ä¢ ${qualityData.accounts} active accounts`;
        }

       // Enhanced Search Intelligence with Google Trends
 function updateSearchIntelligence(data) {
    const trendsData = data.trends_data || {};
    const symbol = data.token_symbol || 'TOKEN';
    
    // Update metrics
    document.getElementById('currentInterest').textContent = trendsData.current_interest || 19;
    document.getElementById('peakInterest').textContent = trendsData.peak_interest || 100;
    
    const momentum = trendsData.momentum || -14.8;
    const momentumEl = document.getElementById('momentum7d');
    momentumEl.textContent = (momentum >= 0 ? '+' : '') + momentum.toFixed(1) + '%';
    momentumEl.style.color = momentum >= 0 ? '#10b981' : '#ef4444';
    
    // Initialize search trends chart
    initSearchTrendsChart(trendsData.chart_data || {}, symbol);
    
    // Initialize geographic heatmap - SIMPLIFIED
    initGeoHeatmap(trendsData.top_countries || []);
    
    document.getElementById('searchIntelligenceDashboard').style.display = 'block';
}
		
		// Search Trends Chart with Chart.js
        function initSearchTrendsChart(chartData, tokenSymbol) {
            const ctx = document.getElementById('searchTrendsChart').getContext('2d');
            
            if (searchTrendsChart) searchTrendsChart.destroy();
            
            let labels = chartData.labels || [];
            let data = chartData.data || [];
            
            // Generate sample data if no real data
            if (labels.length === 0) {
                const days = ['May 15', 'May 17', 'May 19', 'May 21', 'May 23', 'May 25', 'May 27', 'May 29', 'May 31', 'Jun 1'];
                const values = [12, 28, 35, 18, 25, 32, 28, 15, 22, 19];
                labels = days;
                data = values;
            }
            
            searchTrendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Search Interest for ${tokenSymbol}`,
                        data: data,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.4,
                        fill: true,
                        borderWidth: 2,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: '#10b981',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#b0b7ff', font: { size: 10 } }
                        },
                        x: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { 
                                color: '#b0b7ff', 
                                font: { size: 9 },
                                maxRotation: 45
                            }
                        }
                    }
                }
            });
        }

        // Geographic Heatmap with Plotly
  
	function initGeoHeatmap(countriesData) {
    console.log('Initializing heatmap with data:', countriesData);
    
    // Simple validation
    if (!countriesData || !Array.isArray(countriesData) || countriesData.length === 0) {
        console.log('No countries data, showing fallback message');
        showNoHeatmapData();
        return;
    }
    
    // Simple country code mapping - only major countries
    const countryMap = {
        'United States': 'USA',
        'United Kingdom': 'GBR', 
        'Germany': 'DEU',
        'France': 'FRA',
        'Japan': 'JPN',
        'Canada': 'CAN',
        'Australia': 'AUS',
        'Italy': 'ITA',
        'Spain': 'ESP',
        'Netherlands': 'NLD',
        'Brazil': 'BRA',
        'India': 'IND',
        'China': 'CHN',
        'South Korea': 'KOR',
        'Singapore': 'SGP'
    };
    
    // Process countries with simple mapping
    const validCountries = [];
    countriesData.forEach(item => {
        if (item && item.country && countryMap[item.country]) {
            validCountries.push({
                code: countryMap[item.country],
                name: item.country,
                interest: item.interest || 0
            });
        }
    });
    
    console.log('Valid countries for heatmap:', validCountries);
    
    if (validCountries.length === 0) {
        showNoHeatmapData();
        return;
    }
    
    // Create simple Plotly heatmap
    createSimpleHeatmap(validCountries);
}

		function createSimpleHeatmap(countries) {
    try {
        console.log('Creating simple heatmap with countries:', countries);
        
        const data = [{
            type: 'choropleth',
            locations: countries.map(c => c.code),
            z: countries.map(c => c.interest),
            text: countries.map(c => `${c.name}: ${c.interest}%`),
            colorscale: [
                [0, 'rgba(16, 185, 129, 0.2)'],
                [0.5, 'rgba(16, 185, 129, 0.6)'],
                [1, 'rgba(16, 185, 129, 1)']
            ],
            colorbar: {
                title: 'Interest %',
                titlefont: { color: '#b0b7ff', size: 12 },
                tickfont: { color: '#b0b7ff', size: 10 },
                bgcolor: 'rgba(255, 255, 255, 0.1)',
                bordercolor: 'rgba(255, 255, 255, 0.2)',
                thickness: 15,
                len: 0.7
            },
            hovertemplate: '%{text}<extra></extra>'
        }];
        
        const layout = {
            geo: {
                projection: { type: 'natural earth' },
                bgcolor: 'rgba(0, 0, 0, 0)',
                showframe: false,
                showcoastlines: true,
                coastlinecolor: 'rgba(255, 255, 255, 0.3)',
                showland: true,
                landcolor: 'rgba(255, 255, 255, 0.05)',
                showocean: true,
                oceancolor: 'rgba(0, 0, 0, 0.2)',
                showcountries: true,
                countrycolor: 'rgba(255, 255, 255, 0.1)'
            },
            plot_bgcolor: 'rgba(0, 0, 0, 0)',
            paper_bgcolor: 'rgba(0, 0, 0, 0)',
            margin: { t: 10, b: 10, l: 10, r: 10 },
            height: 280,
            font: { color: '#b0b7ff' }
        };
        
        const config = {
            displayModeBar: false,
            responsive: true,
            staticPlot: false
        };
        
        // Clear container and create plot
        const container = document.getElementById('geoHeatmap');
        if (container) {
            container.innerHTML = '';
            Plotly.newPlot('geoHeatmap', data, layout, config)
                .then(() => {
                    console.log('Heatmap created successfully');
                })
                .catch(error => {
                    console.error('Plotly error:', error);
                    showNoHeatmapData();
                });
        }
        
    } catch (error) {
        console.error('Error creating heatmap:', error);
        showNoHeatmapData();
    }
}

// SIMPLIFIED No Data Handling
function showNoHeatmapData() {
    const heatmapContainer = document.getElementById('geoHeatmap');
    if (heatmapContainer) {
        heatmapContainer.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #b0b7ff;">
                <div style="font-size: 3rem; margin-bottom: 15px; opacity: 0.7;">üåç</div>
                <h4 style="color: #f59e0b; margin-bottom: 10px;">Limited Geographic Data</h4>
                <p style="font-size: 0.9rem; margin-bottom: 8px;">This token has minimal global search interest</p>
                <p style="font-size: 0.8rem; opacity: 0.8;">Try analyzing a more popular token to see geographic trends</p>
            </div>
        `;
    }
}
function updateTokenProfile(data) {
         const profile = document.getElementById('tokenProfile');
    
    // Get token image from rug analysis or market data
    const tokenImage = data.rug_analysis?.token_info?.logo || 
                      data.rug_analysis?.token_info?.profile_image || 
                      data.token_image || '';
    
    // Update token info with image
    document.getElementById('tokenName').textContent = `${data.token_symbol} - ${data.token_name || data.token_symbol + ' Token'}`;
    document.getElementById('tokenContract').textContent = `${data.token_address.slice(0, 8)}...${data.token_address.slice(-8)}`;
    
    // Update token image
    const tokenImageEl = document.getElementById('tokenImage');
    if (tokenImage) {
        tokenImageEl.src = tokenImage;
        tokenImageEl.style.display = 'block';
    } else {
        tokenImageEl.style.display = 'none';
    }
    
    // Use market cap from main analysis, not rug check (to avoid duplication)
    const metricsHtml = `
        <div class="metric-card">
            <div class="metric-value">${(data.price_usd || 0).toFixed(8)}</div>
            <div class="metric-label">Price USD</div>
        </div>
        <div class="metric-card">
            <div class="metric-value ${data.price_change_24h >= 0 ? 'positive' : 'negative'}">${data.price_change_24h >= 0 ? '+' : ''}${(data.price_change_24h || 0).toFixed(2)}%</div>
            <div class="metric-label">24h Change</div>
        </div>
        <div class="metric-card">
            <div class="metric-value">${((data.market_cap || 0) / 1e6).toFixed(1)}M</div>
            <div class="metric-label">Market Cap</div>
        </div>
        <div class="metric-card">
            <div class="metric-value">${data.galaxy_brain_score || 50}/100</div>
            <div class="metric-label">Safety Score</div>
        </div>
        <div class="metric-card">
            <div class="metric-value">${((data.liquidity || 0) / 1e6).toFixed(1)}M</div>
            <div class="metric-label">Liquidity</div>
        </div>
    `;
    document.getElementById('tokenMetrics').innerHTML = metricsHtml;
    
    profile.style.display = 'block';
}


function updateSafetyDashboard(data) {
    const rugAnalysis = data.rug_analysis || {};
    const safetyMetrics = data.safety_metrics || {};
    const riskVectors = data.risk_vectors || [];
    
    // Create safety dashboard HTML
    const safetyHtml = `
        <div class="safety-overview">
            <div class="safety-score-card">
                <div class="safety-score">${data.galaxy_brain_score || 50}</div>
                <div class="safety-level">${data.safety_level || 'UNKNOWN'}</div>
                <div class="confidence">Confidence: ${Math.round((data.confidence_level || 0.5) * 100)}%</div>
            </div>
        </div>
        
<!-- Risk Vectors -->
            <div class="risk-vectors-grid" id="riskVectorsGrid"></div>

            <!-- Advanced Metrics -->
            <div class="advanced-metrics" id="advancedMetrics"></div>

            <!-- Charts Section -->
            <div class="chart-section">
                <div class="chart-container">
                    <h3 class="chart-title">üß† Revolutionary Risk Breakdown</h3>
                    <canvas id="riskBreakdownChart" class="chart-canvas"></canvas>
                </div>
                
                <div class="chart-container">
                    <h3 class="chart-title">üë• Holder Distribution Analysis</h3>
                    <canvas id="holderChart" class="chart-canvas"></canvas>
                </div>
                
                <div class="chart-container">
                    <h3 class="chart-title">üîÑ Transaction Health Score</h3>
                    <canvas id="transactionChart" class="chart-canvas"></canvas>
                </div>
                
                <div class="chart-container">
                    <h3 class="chart-title">üï∑Ô∏è Bundle Detection Results</h3>
                    <canvas id="bundleChart" class="chart-canvas"></canvas>
                </div>
            </div>

            <!-- Detailed Analysis Tabs -->
            <div class="detailed-analysis">
                <div class="analysis-tabs">
                    <button class="tab-btn active" onclick="showTab('holders')">üë• Holders</button>
                    <button class="tab-btn" onclick="showTab('transactions')">üîÑ Transactions</button>
                    <button class="tab-btn" onclick="showTab('bundles')">üï∑Ô∏è Bundles</button>
                    <button class="tab-btn" onclick="showTab('liquidity')">üíß Liquidity</button>
                </div>
                
                <div class="tab-content active" id="holders-tab">
                    <div class="holder-list">
                        <h3 style="margin-bottom: 20px;">üêã Top Holders Analysis</h3>
                        <div id="holdersList"></div>
                    </div>
                </div>
                
                <div class="tab-content" id="transactions-tab">
                    <div id="transactionAnalysis"></div>
                </div>
                
                <div class="tab-content" id="bundles-tab">
                    <div id="bundleDetection"></div>
                </div>
                
                <div class="tab-content" id="liquidity-tab">
                    <div id="liquidityAnalysis"></div>
                </div>
            </div>
    `;
    
    // Insert into your results section
    const resultsSection = document.getElementById('resultsSection');
    const safetyDashboard = document.createElement('div');
    safetyDashboard.className = 'safety-dashboard';
    safetyDashboard.innerHTML = safetyHtml;
    
    // Insert after token profile
    const tokenProfile = document.getElementById('tokenProfile');
    tokenProfile.insertAdjacentElement('afterend', safetyDashboard);
}

        // Updated momentum dashboard to use real sentiment data
        function updateMomentumDashboard(data) {
            const realSocialData = data.real_social_data || {};
            const sentimentSummary = realSocialData.sentiment_summary || {};
            
            // Calculate momentum score from real data
            let momentumScore = 50; // Default neutral
            if (realSocialData.has_real_data) {
                const tweets = realSocialData.tweets || [];
                const bullishTweets = tweets.filter(t => t.sentiment === 'bullish').length;
                const totalTweets = tweets.length;
                if (totalTweets > 0) {
                    momentumScore = Math.round((bullishTweets / totalTweets) * 100);
                }
            }
            
            const scoreEl = document.getElementById('momentumScore');
            
            // Animate score counting up
            let currentScore = 0;
            const increment = momentumScore / 60;
            const counter = setInterval(() => {
                currentScore += increment;
                if (currentScore >= momentumScore) {
                    currentScore = momentumScore;
                    clearInterval(counter);
                }
                scoreEl.textContent = Math.round(currentScore);
            }, 25);

            // Update metrics with real data
            const metricsData = [
                { label: 'Real Data', value: realSocialData.has_real_data ? 100 : 0, unit: '%' },
                { label: 'Tweets', value: realSocialData.total_tweets_found || 0, unit: '' },
                { label: 'Accounts', value: realSocialData.total_accounts_found || 0, unit: '' },
                { label: 'Topics', value: (realSocialData.discussion_topics || []).length, unit: '' },
                { label: 'Sentiment', value: momentumScore, unit: '%' },
                { label: 'Quality', value: realSocialData.data_quality === 'real' ? 100 : realSocialData.data_quality === 'limited' ? 50 : 0, unit: '%' }
            ];

            let metricsHtml = '';
            metricsData.forEach(metric => {
                const percentage = metric.value;
                metricsHtml += `
                    <div class="momentum-metric">

                        <div class="metric-visual" style="background: conic-gradient(#0040ff 0deg, #00e5ff 72deg, #00ff00 144deg, #ffff00 216deg, #ff7f00 288deg, #ff0000 ${percentage * 3.6}deg, rgba(255,255,255,0.1) ${percentage * 3.6}deg, rgba(255,255,255,0.1) 360deg);"></div>
                        <div class="metric-value-main">${metric.value}${metric.unit}</div>
                        <div class="metric-label-main">${metric.label}</div>
                    </div>
                `;
            });
            
            document.getElementById('momentumMetrics').innerHTML = metricsHtml;
        }

function updateTweetsSection(data) {
    console.log('Updating accounts section with Grok API data:', data.real_social_data);
    
    const realSocialData = data.real_social_data || {};
    const accountTable = realSocialData.account_table || [];
    const topAccounts = realSocialData.top_accounts || [];
    
    // Update with new Grok API table format
    updateAccountsTable(accountTable, realSocialData);
    
    // Update Who to Follow (using existing structure)
    updateWhoToFollow(topAccounts);
    
    // Update engagement summary
    updateEngagementSummary(realSocialData);
}

function updateEngagementSummary(socialData) {
    const accountTable = socialData.account_table || [];
    const totalAccounts = accountTable.length;
    
    // Calculate average engagement
    const totalEngagement = accountTable.reduce((sum, account) => sum + (account.total_engagement || 0), 0);
    const avgEngagement = totalAccounts > 0 ? Math.round(totalEngagement / totalAccounts) : 0;
    
    // Update summary elements
    document.getElementById('totalAccounts').textContent = totalAccounts;
    document.getElementById('avgEngagement').textContent = formatEngagementCount(avgEngagement);
    
    const qualityElement = document.getElementById('dataQuality');
    const quality = socialData.data_quality || 'unknown';
    qualityElement.textContent = quality.toUpperCase();
    qualityElement.style.color = getQualityColor(quality);
}

function updateRecentDiscussion(tweets) {
    let tweetsHtml = '';
    
    if (tweets.length > 0) {
        tweets.forEach(tweet => {
            const timeAgo = getTimeAgo(tweet.created_at);
            const engagement = formatEngagement(tweet.likes, tweet.retweets, tweet.replies);
            
            tweetsHtml += `
                <div class="tweet-item" onclick="window.open('${tweet.url}', '_blank')">
                    <div class="tweet-header">
                        <a href="https://x.com/${tweet.username}" target="_blank" class="tweet-author">
                            @${tweet.username}
                            ${tweet.verified ? ' ‚úì' : ''}
                        </a>
                        <div class="tweet-meta">
                            <span>${timeAgo}</span>
                            <span class="tweet-sentiment sentiment-${tweet.sentiment}">${tweet.sentiment}</span>
                        </div>
                    </div>
                    <div class="tweet-content">${tweet.content}</div>
                    <div class="tweet-engagement" style="margin-top: 8px; font-size: 0.75rem; color: #7dd3fc;">
                        ${engagement} ‚Ä¢ ${formatFollowerCount(tweet.followers)} followers
                    </div>
                </div>
            `;
        });
    } else {
        tweetsHtml = `
            <div class="tweet-item" style="text-align: center; opacity: 0.7;">
                <div class="tweet-content">No recent X discussions found. Try analyzing a trending token!</div>
            </div>
        `;
    }
    
    document.getElementById('recentXDiscussionList').innerHTML = tweetsHtml;
}
		
		function updateNotableAccounts(notableAccounts) {
    let accountsHtml = '';
    
    if (notableAccounts.length > 0) {
        notableAccounts.forEach(account => {
            accountsHtml += `
                <div class="notable-account-item" onclick="window.open('${account.url}', '_blank')">
                    <div class="notable-username">@${account.username}</div>
                    <div class="notable-display-name">${account.display_name}</div>
                    <div class="notable-followers">${account.followers_formatted}</div>
                </div>
            `;
        });
    } else {
        accountsHtml = `
            <div class="notable-account-item" style="text-align: center; opacity: 0.7; cursor: default;">
                <div class="notable-display-name">No notable accounts found</div>
            </div>
        `;
    }
    
    document.getElementById('notableAccountsList').innerHTML = accountsHtml;
}

function updateWhoToFollow(topAccounts) {
    console.log('Updating who to follow with', topAccounts.length, 'accounts');
    
    let accountsHtml = '';
    
    if (topAccounts.length > 0) {
        // Sort by engagement score if available
        const sortedAccounts = topAccounts.sort((a, b) => 
            (b.engagement_score || 0) - (a.engagement_score || 0)
        );
        
        sortedAccounts.slice(0, 8).forEach((account, index) => {
            const isTopAccount = index < 3;
            const icon = isTopAccount ? ['ü•á', 'ü•à', 'ü•â'][index] : 'üë§';
            
            accountsHtml += `
                <div class="account-item ${isTopAccount ? 'top-account' : ''}" onclick="window.open('${account.url}', '_blank')">
                    <div class="account-rank">${icon}</div>
                    <div class="account-info">
                        <div class="account-username">@${account.username}</div>
                        <div class="account-followers">${account.followers}</div>
                        <div class="account-activity">${truncateText(account.recent_activity, 60)}</div>
                        ${account.engagement_score ? `
                            <div class="engagement-badge">
                                ‚ö° ${formatEngagementCount(account.engagement_score)} engagement
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        });
    } else {
        accountsHtml = `
            <div class="account-item" style="text-align: center; opacity: 0.7; cursor: default;">
                <div style="font-size: 2rem; margin-bottom: 10px;">üë•</div>
                <div class="account-activity">No account recommendations available</div>
                <div style="font-size: 0.8rem; color: #666; margin-top: 8px;">
                    Try analyzing a token with more social activity
                </div>
            </div>
        `;
    }
    
    document.getElementById('whoToFollowList').innerHTML = accountsHtml;
}
		

function formatEngagementCount(count) {
    if (count === 0 || count === 'N/A' || !count) return 'N/A';
    if (count >= 1000000) return `${(count/1000000).toFixed(1)}M`;
    if (count >= 1000) return `${(count/1000).toFixed(1)}K`;
    return count.toLocaleString();
}

function formatEngagementBreakdown(account) {
    const views = formatEngagementCount(account.view_count);
    const favorites = formatEngagementCount(account.favorite_count);
    const retweets = formatEngagementCount(account.retweet_count);
    
    return `üëÅÔ∏è ${views} ‚Ä¢ ‚ù§Ô∏è ${favorites} ‚Ä¢ üîÑ ${retweets}`;
}

function formatFollowerDisplay(followerCount) {
    if (followerCount === 'N/A' || !followerCount) return 'Unknown followers';
    
    // If it's already formatted, return as is
    if (typeof followerCount === 'string' && followerCount.includes('followers')) {
        return followerCount;
    }
    
    // If it's a number, format it
    if (typeof followerCount === 'number') {
        return formatEngagementCount(followerCount) + ' followers';
    }
    
    // Try to extract number from string
    const match = followerCount.toString().match(/[\d,]+/);
    if (match) {
        const num = parseInt(match[0].replace(/,/g, ''));
        return formatEngagementCount(num) + ' followers';
    }
    
    return followerCount + ' followers';
}

function formatDate(dateString) {
    if (!dateString || dateString === 'N/A' || dateString === 'unknown') return 'Recent';
    
    try {
        const date = new Date(dateString);
        if (isNaN(date.getTime())) return dateString; // Return original if not a valid date
        
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 1) return 'Yesterday';
        if (diffDays <= 7) return `${diffDays}d ago`;
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    } catch (e) {
        return dateString;
    }
}

function truncateText(text, maxLength) {
    if (!text || text === 'N/A') return '';
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
}

function openAccountLink(username) {
    if (username && username !== 'unknown') {
        window.open(`https://x.com/${username}`, '_blank');
    }
}

function getQualityColor(quality) {
    switch (quality) {
        case 'real': return '#10b981';
        case 'limited': return '#f59e0b';
        case 'no_data': return '#ef4444';
        default: return '#6b7280';
    }
}

// Enhanced account item styling for top accounts
const enhancedStyles = `
<style>
.account-item.top-account {
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(102, 126, 234, 0.1) 100%);
    border: 1px solid rgba(16, 185, 129, 0.3);
    position: relative;
}

.account-item.top-account::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, #10b981, #667eea);
    border-radius: 8px 8px 0 0;
}

.account-rank {
    font-size: 1.2rem;
    margin-bottom: 5px;
}

.account-info {
    flex: 1;
}

.engagement-badge {
    background: rgba(16, 185, 129, 0.2);
    color: #10b981;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 0.7rem;
    font-weight: 600;
    margin-top: 6px;
    display: inline-block;
}

.account-item {
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

.loading-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 200px;
}
</style>
`;

// Add enhanced styles to document
if (!document.getElementById('enhanced-account-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'enhanced-account-styles';
    styleElement.textContent = enhancedStyles.replace(/<\/?style>/g, '');
    document.head.appendChild(styleElement);
}





function getTimeAgo(dateString) {
    try {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMins / 60);
        const diffDays = Math.floor(diffHours / 24);
        
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        return `${diffDays}d ago`;
    } catch (e) {
        return 'Recent';
    }
}

function formatEngagement(likes, retweets, replies) {
    const total = likes + retweets + replies;
    if (total >= 1000) return `${(total/1000).toFixed(1)}K interactions`;
    return `${total} interactions`;
}

function formatFollowerCount(count) {
    if (count >= 1000000) return `${(count/1000000).toFixed(1)}M`;
    if (count >= 1000) return `${(count/1000).toFixed(0)}K`;
    return count.toString();
}

        function updateExpertAnalysis(data) {
            const analysis = data.expert_analysis || 'Connect XAI API for comprehensive expert analysis with real-time market insights and trading perspectives.';
            document.getElementById('expertAnalysis').innerHTML = analysis;
        }

        function updateAnalysisCards(data) {
            // Trading Signals
            const signals = data.trading_signals || [];
            let signalsHtml = '';
            if (signals.length > 0) {
                signals.forEach(signal => {
                    const emoji = {'BUY': 'üü¢', 'SELL': 'üî¥', 'HOLD': 'üü°', 'WATCH': 'üëÄ'}[signal.signal_type] || '‚ö™';
                    signalsHtml += `
                        <div class="content-heading">${emoji} ${signal.signal_type}</div>
                        <p>${signal.reasoning}</p>
                        <p><strong>Confidence:</strong> ${Math.round(signal.confidence * 100)}%</p>
                    `;
                });
            } else {
                signalsHtml = '<p>Connect XAI API for real-time trading signals based on social momentum and market analysis.</p>';
            }
            document.getElementById('tradingSignals').innerHTML = signalsHtml;
            
            // Risk Assessment - Enhanced formatting with tables/icons
            let riskHtml = data.risk_assessment || '';
            if (riskHtml && riskHtml.includes('**')) {
                // Parse structured risk data and format with icons/tables
                riskHtml = formatRiskAssessment(riskHtml);
            } else {
                riskHtml = `
                    <div class="content-heading">‚ö†Ô∏è Risk Assessment</div>
                    <p>Connect XAI API for comprehensive risk analysis including market cap assessment, liquidity analysis, and volatility metrics.</p>
                `;
            }
            document.getElementById('riskAssessment').innerHTML = riskHtml;
            
            // Market Predictions - Enhanced formatting with tables/icons
            let predictionHtml = data.market_predictions || '';
            if (predictionHtml && predictionHtml.includes('**')) {
                // Parse structured prediction data and format with icons/tables
                predictionHtml = formatMarketPredictions(predictionHtml);
            } else {
                predictionHtml = `
                    <div class="content-heading">üîÆ Market Predictions</div>
                    <p>Connect XAI API for AI-powered market predictions based on social momentum, technical analysis, and fundamental metrics.</p>
                `;
            }
            document.getElementById('marketPredictions').innerHTML = predictionHtml;
        }

        function formatRiskAssessment(riskData) {
            // Parse structured risk data and format with icons/tables
            let html = '<div class="risk-table">';
            
            const lines = riskData.split('\n');
            lines.forEach(line => {
                if (line.includes('**Risk Level:')) {
                    const riskLevel = line.match(/Risk Level:\s*(\w+)/i);
                    if (riskLevel) {
                        const level = riskLevel[1].toUpperCase();
                        const icon = level === 'HIGH' ? 'üî¥' : level === 'MEDIUM' ? 'üü°' : 'üü¢';
                        const className = level === 'HIGH' ? 'risk-high' : level === 'MEDIUM' ? 'risk-medium' : 'risk-low';
                        html += `
                            <div class="risk-item">
                                <div class="risk-icon">${icon}</div>
                                <div class="risk-text">
                                    <strong>Overall Risk</strong>
                                    <div class="risk-level ${className}">${level}</div>
                                </div>
                            </div>
                        `;
                    }
                } else if (line.includes('**') && line.includes('Risk:')) {
                    const type = line.match(/\*\*([^*]+Risk):\*\*/);
                    const value = line.split('**')[2]?.trim();
                    if (type && value) {
                        const icon = type[1].includes('Liquidity') ? 'üíß' : type[1].includes('Volatility') ? 'üìä' : 'üí∞';
                        html += `
                            <div class="risk-item">
                                <div class="risk-icon">${icon}</div>
                                <div class="risk-text">
                                    <strong>${type[1]}</strong>
                                    <div>${value}</div>
                                </div>
                            </div>
                        `;
                    }
                }
            });
            
            html += '</div>';
            return html;
        }

        function formatMarketPredictions(predictionData) {
            // Parse structured prediction data and format with icons/tables
            let html = '<div class="prediction-list">';
            
            const lines = predictionData.split('\n');
            lines.forEach(line => {
                if (line.includes('**') && line.includes('Outlook:')) {
                    const outlook = line.match(/Outlook:\s*(\w+)/i);
                    if (outlook) {
                        const trend = outlook[1].toUpperCase();
                        const icon = trend === 'BULLISH' ? 'üöÄ' : trend === 'BEARISH' ? 'üìâ' : '‚û°Ô∏è';
                        html += `
                            <div class="prediction-item">
                                <div class="prediction-icon">${icon}</div>
                                <div class="prediction-text">
                                    <strong>7-Day Outlook: ${trend}</strong>
                                </div>
                            </div>
                        `;
                    }
                } else if (line.includes('**') && (line.includes('Catalysts') || line.includes('Targets'))) {
                    const type = line.match(/\*\*([^*]+):\*\*/);
                    if (type) {
                        const icon = type[1].includes('Catalysts') ? '‚ö°' : 'üéØ';
                        const content = line.split('**')[2]?.trim() || 'Data pending...';
                        html += `
                            <div class="prediction-item">
                                <div class="prediction-icon">${icon}</div>
                                <div class="prediction-text">
                                    <strong>${type[1]}</strong>
                                    <div>${content}</div>
                                </div>
                            </div>
                        `;
                    }
                }
            });
            
            html += '</div>';
            return html;
        }

        // Chat Functions
function enableChatWithContext() {
    // This function is kept for backward compatibility but now just calls enableChatPopup
    enableChatPopup();
}

        async function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (!message || !currentTokenAddress) return;

            addChatMessage(message, 'user');
            chatInput.value = '';

            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        token_address: currentTokenAddress,
                        message: message,
                        history: chatHistory
                    })
                });

                const data = await response.json();
                
                if (data.response) {
                    addChatMessage(data.response, 'assistant');
                } else {
                    addChatMessage('Sorry, I encountered an error. Please try again.', 'assistant');
                }
                
            } catch (error) {
                console.error('Chat error:', error);
                addChatMessage('Connection error. Please try again.', 'assistant');
            }
        }

        function addChatMessage(message, sender) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;
            messageDiv.textContent = message;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            chatHistory.push({
                role: sender === 'user' ? 'user' : 'assistant',
                content: message
            });
            
            if (chatHistory.length > 10) { // Keep shorter history for shorter responses
                chatHistory = chatHistory.slice(-10);
            }
        }

function hideResults() {
    const elementsToHide = [
        'resultsSection',
        'chartContainer', 
        'tokenProfile',
        'tokenAgeDashboard',
        'realSocialDashboard',
        'searchIntelligenceDashboard'
    ];
    
    elementsToHide.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.style.display = 'none';
        }
    });
    
    // Destroy new real data charts to prevent memory leaks
[liveTweetSentimentChart, activeAccountsChart, discussionTopicsChart, platformDistributionChart, realTrendsChart, searchTrendsChart, sentimentTimelineChart, greedGaugeChart, euphoriaGaugeChart, diamondGaugeChart].forEach(chart => {
        if (chart) {
            chart.destroy();
        }
    });
    
    // Destroy gauge chart instances
    ['greedGaugeChartInstance', 'euphoriaGaugeChartInstance', 'diamondGaugeChartInstance'].forEach(instanceName => {
        if (window[instanceName]) {
            window[instanceName].destroy();
            window[instanceName] = null;
        }
    });
}

const FREE_TIER_CONFIG = {
    categories: ['trending', 'volume', 'latest'],
    categoryNames: ['üî• Trending', 'üí∞ Volume Spike', '‚ú® Latest Tokens'],
    loadOnDemand: true,  // Only load when tab is clicked
    cacheTime: 30 * 60 * 1000,  // 30 minutes cache
    retryDelay: 5000  // 5 seconds before retry on error
};

class TrendingTokensManager {
    constructor() {
        this.currentCategory = 'trending';
        this.loadedCategories = new Set();
        this.loadingStates = new Map();
        this.errorStates = new Map();
        this.lastLoadTimes = new Map();
        
        this.init();
    }
    
    init() {
        this.createTabs();
        this.setupEventListeners();
        
        // Load only the first tab initially (to avoid rate limit)
        this.loadCategory('trending', false);
    }
    
    createTabs() {
        const tabsContainer = document.querySelector('.trending-tabs') || 
                             document.querySelector('.tabs-container') ||
                             document.createElement('div');
        
        if (!tabsContainer.parentNode) {
            // Create container if it doesn't exist
            const container = document.querySelector('.trending-section') || 
                             document.querySelector('.dashboard-section');
            if (container) {
                tabsContainer.className = 'trending-tabs';
                container.insertBefore(tabsContainer, container.firstChild);
            }
        }
        
        tabsContainer.innerHTML = FREE_TIER_CONFIG.categories.map((category, index) => `
            <button class="tab-button ${index === 0 ? 'active' : ''}" 
                    data-category="${category}"
                    id="tab-${category}">
                ${FREE_TIER_CONFIG.categoryNames[index]}
                <span class="tab-status"></span>
            </button>
        `).join('');
    }
    
    setupEventListeners() {
        // Tab click handlers
        document.addEventListener('click', (event) => {
            if (event.target.closest('.tab-button')) {
                const button = event.target.closest('.tab-button');
                const category = button.dataset.category;
                this.switchTab(category, button);
            }
        });
        
        // Refresh button handler
        const refreshButton = document.querySelector('.refresh-trending');
        if (refreshButton) {
            refreshButton.addEventListener('click', () => {
                this.refreshCurrentCategory();
            });
        }
    }
    
    switchTab(category, buttonElement) {
        // Don't switch if already loading
        if (this.loadingStates.get(category)) {
            console.log(`Tab ${category} is already loading...`);
            return;
        }
        
        // Update active tab
        document.querySelectorAll('.tab-button').forEach(btn => {
            btn.classList.remove('active');
        });
        buttonElement.classList.add('active');
        
        this.currentCategory = category;
        
        // Load category data (with caching)
        this.loadCategory(category, false);
    }
    
    async loadCategory(category, forceRefresh = false) {
        try {
            // Check if we should use cache
            if (!forceRefresh && this.shouldUseCache(category)) {
                console.log(`‚úÖ Using cached data for ${category}`);
                return;
            }
            
            // Prevent multiple simultaneous loads
            if (this.loadingStates.get(category)) {
                console.log(`‚è≥ ${category} already loading...`);
                return;
            }
            
            // Clear any previous errors
            this.clearError(category);
            
            // Set loading state
            this.setLoadingState(category, true);
            this.showLoadingUI(category);
            
            console.log(`üöÄ Loading ${category} tokens from API...`);
            
            const response = await fetch(`/trending-tokens?category=${category}&refresh=${forceRefresh}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                },
                // Add timeout for free tier
                signal: AbortSignal.timeout(30000)  // 30 second timeout
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${await response.text()}`);
            }
            
            const data = await response.json();
            
            if (data.success && data.tokens && data.tokens.length > 0) {
                this.displayTokens(data.tokens, category);
                this.markCategoryLoaded(category);
                console.log(`‚úÖ Successfully loaded ${data.tokens.length} ${category} tokens`);
            } else {
                throw new Error(data.error || 'No tokens returned');
            }
            
        } catch (error) {
            console.error(`‚ùå Error loading ${category}:`, error);
            
            if (error.name === 'AbortError') {
                this.showError(category, 'Request timeout - API taking too long');
            } else if (error.message.includes('429')) {
                this.showError(category, 'Rate limit hit - Free tier (1/sec) exceeded');
            } else {
                this.showError(category, error.message);
            }
            
            // Show fallback data if available
            this.showFallbackData(category);
            
        } finally {
            this.setLoadingState(category, false);
        }
    }
    
    shouldUseCache(category) {
        const lastLoad = this.lastLoadTimes.get(category);
        if (!lastLoad) return false;
        
        const cacheAge = Date.now() - lastLoad;
        return cacheAge < FREE_TIER_CONFIG.cacheTime && this.loadedCategories.has(category);
    }
    
    setLoadingState(category, isLoading) {
        this.loadingStates.set(category, isLoading);
        
        const tabButton = document.getElementById(`tab-${category}`);
        const statusSpan = tabButton?.querySelector('.tab-status');
        
        if (statusSpan) {
            if (isLoading) {
                statusSpan.innerHTML = '<span class="spinner-small"></span>';
                statusSpan.className = 'tab-status loading';
            } else {
                statusSpan.innerHTML = '';
                statusSpan.className = 'tab-status';
            }
        }
    }
    
    showLoadingUI(category) {
        if (this.currentCategory !== category) return;
        
        const container = this.getTokensContainer();
        if (container) {
            container.innerHTML = `
                <div class="loading-state-free-tier">
                    <div class="spinner-large"></div>
                    <h3>Loading ${category} tokens...</h3>
                    <p class="free-tier-note">
                        üïê Free tier: Please wait for rate limiting (1 request/second)
                    </p>
                </div>
            `;
        }
    }
    
    showError(category, errorMessage) {
        this.errorStates.set(category, {
            message: errorMessage,
            timestamp: Date.now()
        });
        
        if (this.currentCategory !== category) return;
        
        const container = this.getTokensContainer();
        if (container) {
            const isRateLimit = errorMessage.includes('rate limit') || 
                               errorMessage.includes('429');
            
            container.innerHTML = `
                <div class="error-state-free-tier ${isRateLimit ? 'rate-limit' : ''}">
                    <div class="error-icon">${isRateLimit ? 'üïê' : '‚ö†Ô∏è'}</div>
                    <h3>${isRateLimit ? 'Rate Limit Reached' : 'Loading Error'}</h3>
                    <p class="error-message">${errorMessage}</p>
                    ${isRateLimit ? `
                        <div class="rate-limit-info">
                            <p><strong>Free Tier Limits:</strong></p>
                            <ul>
                                <li>1 request per second</li>
                                <li>10,000 requests per month</li>
                                <li>Consider upgrading for higher limits</li>
                            </ul>
                        </div>
                    ` : ''}
                    <button onclick="trendingManager.retryCategory('${category}')" 
                            class="retry-button">
                        üîÑ Retry in 5 seconds
                    </button>
                    <div class="retry-countdown" id="countdown-${category}"></div>
                </div>
            `;
            
            // Start countdown for retry
            this.startRetryCountdown(category);
        }
    }
    
    startRetryCountdown(category) {
        let seconds = 5;
        const countdownEl = document.getElementById(`countdown-${category}`);
        
        const countdown = setInterval(() => {
            if (countdownEl) {
                countdownEl.textContent = `Auto-retry in ${seconds} seconds...`;
            }
            
            seconds--;
            
            if (seconds < 0) {
                clearInterval(countdown);
                // Auto-retry
                this.retryCategory(category);
            }
        }, 1000);
    }
    
    retryCategory(category) {
        console.log(`üîÑ Retrying ${category}...`);
        this.clearError(category);
        this.loadCategory(category, true);
    }
    
    clearError(category) {
        this.errorStates.delete(category);
    }
    
    displayTokens(tokens, category) {
        if (this.currentCategory !== category) return;
        
        const container = this.getTokensContainer();
        if (!container) return;
        
        const tokensHtml = tokens.map(token => this.createTokenCard(token)).join('');
        
        container.innerHTML = `
            <div class="tokens-grid">
                ${tokensHtml}
            </div>
            <div class="free-tier-footer">
                <p>üìä Data from Solana Tracker API (Free Tier) ‚Ä¢ Updated: ${new Date().toLocaleTimeString()}</p>
            </div>
        `;
    }
    
    createTokenCard(token) {
        const changeClass = token.price_change >= 0 ? 'positive' : 'negative';
        const changeIcon = token.price_change >= 0 ? 'üìà' : 'üìâ';
        
        return `
            <div class="token-card" onclick="loadTokenAnalysis('${token.address}')">
                <div class="token-header">
                    <span class="token-symbol">${token.symbol}</span>
                    <span class="price-change ${changeClass}">
                        ${changeIcon} ${token.price_change > 0 ? '+' : ''}${token.price_change.toFixed(2)}%
                    </span>
                </div>
                <div class="token-metrics">
                    <div class="metric">
                        <span class="label">Volume 24h:</span>
                        <span class="value">${this.formatNumber(token.volume)}</span>
                    </div>
                    <div class="metric">
                        <span class="label">Market Cap:</span>
                        <span class="value">${this.formatNumber(token.market_cap)}</span>
                    </div>
                    <div class="metric">
                        <span class="label">Sentiment:</span>
                        <span class="value">${(token.sentiment_score * 100).toFixed(0)}%</span>
                    </div>
                </div>
                <div class="token-footer">
                    <span class="mentions">${token.mentions} mentions</span>
                    <span class="category-badge">${token.category}</span>
                </div>
            </div>
        `;
    }
    
    showFallbackData(category) {
        // Show cached data or static fallback
        console.log(`üì¶ Showing fallback data for ${category}`);
        // Implementation depends on your fallback strategy
    }
    
    markCategoryLoaded(category) {
        this.loadedCategories.add(category);
        this.lastLoadTimes.set(category, Date.now());
    }
    
    refreshCurrentCategory() {
        console.log(`üîÑ Refreshing ${this.currentCategory}...`);
        this.loadCategory(this.currentCategory, true);
    }
    
    formatNumber(num) {
        if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
        if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
        if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
        return num.toFixed(2);
    }
    
    getTokensContainer() {
        return document.querySelector('.trending-tokens-container') ||
               document.querySelector('.tokens-container') ||
               document.querySelector('.dashboard-content');
    }
}

// Initialize trending tokens manager (called from main DOMContentLoaded if needed)
let trendingManager;

function initializeTrendingManager() {
    if (typeof TrendingTokensManager !== 'undefined') {
        console.log('üöÄ Initializing Trending Tokens Manager...');
        trendingManager = new TrendingTokensManager();
        addFreeTierStyles();
    }
}

function addFreeTierStyles() {
    const styles = `
        <style>
        .tab-status.loading .spinner-small {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #333;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }
        
        .loading-state-free-tier {
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 12px;
            margin: 20px 0;
        }
        
        .spinner-large {
            width: 40px;
            height: 40px;
            border: 4px solid #333;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        .free-tier-note {
            color: #ffa500;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .error-state-free-tier {
            text-align: center;
            padding: 30px 20px;
            background: #2a1810;
            border: 1px solid #ff6b47;
            border-radius: 12px;
            margin: 20px 0;
        }
        
        .error-state-free-tier.rate-limit {
            background: #1a2a1a;
            border-color: #ffa500;
        }
        
        .error-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .rate-limit-info {
            background: rgba(255, 165, 0, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: left;
        }
        
        .rate-limit-info ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .retry-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 15px 0;
            transition: transform 0.2s;
        }
        
        .retry-button:hover {
            transform: translateY(-2px);
        }
        
        .retry-countdown {
            color: #ffa500;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .free-tier-footer {
            text-align: center;
            padding: 15px;
            color: #888;
            font-size: 12px;
            border-top: 1px solid #333;
            margin-top: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        </style>
    `;
    
    document.head.insertAdjacentHTML('beforeend', styles);
}

        // Utility Functions

        function showLoading() {
            document.getElementById('loadingSpinner').style.display = 'block';
            document.querySelector('.analyze-btn').disabled = true;
        }

        function hideLoading() {
            document.getElementById('loadingSpinner').style.display = 'none';
            document.querySelector('.analyze-btn').disabled = false;
        }

        function updateLoadingText(message) {
            document.getElementById('loadingText').textContent = message;
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }
    </script>
	<script>
/* --- ultra-light "slow-mo" arrow-key scroller --- */
const STEP = 10;                       // px per key repeat ‚Üí lower = slower
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowDown') {
    e.preventDefault();                // kill the native 40 px jump
    window.scrollBy({ top:  STEP, behavior: 'smooth' });
  }
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    window.scrollBy({ top: -STEP, behavior: 'smooth' });
  }
});


// Safety Analysis Functions - Add these to your existing index.html script section

// Global variables for safety charts
let revolutionaryRiskChart = null;
let holderDistributionChart = null;
let transactionHealthChart = null;
let bundleDetectionChart = null;

// Main function to update safety dashboard
function updateSafetyDashboard(data) {
    console.log('Updating safety dashboard with data:', data);
    
    // Show the safety dashboard
    document.getElementById('safetyAnalysisDashboard').style.display = 'block';
    
    // Extract safety data from the response
    const rugAnalysis = data.rug_analysis || {};
    const safetyMetrics = data.safety_metrics || rugAnalysis;
    
    // Update Galaxy Brain Score
    updateGalaxyBrainScore(safetyMetrics);
    
    // Update Grok Intelligence if available
    updateGrokIntelligence(rugAnalysis.grok_analysis);
    
    // Update Risk Vectors
    updateRiskVectors(rugAnalysis.risk_vectors || []);
    
    // Update Advanced Metrics
    updateAdvancedSafetyMetrics(rugAnalysis);
    
    // Update Safety Charts
    updateSafetyCharts(rugAnalysis);
    
    // Update Detailed Analysis Tabs
    updateDetailedSafetyTabs(rugAnalysis);
}

// Update Galaxy Brain Score display
function updateGalaxyBrainScore(safetyMetrics) {
    const score = safetyMetrics.galaxy_brain_score || 0;
    const severity = safetyMetrics.severity_level || 'UNKNOWN';
    const confidence = safetyMetrics.confidence || 0;
    
    // Animate score counting up
    animateScoreCounter('galaxyBrainScore', score);
    
    // Update severity level with color coding
    const severityEl = document.getElementById('safetyLevel');
    severityEl.textContent = severity.replace(/_/g, ' ');
    severityEl.className = `severity-level ${severity.toLowerCase()}`;
    
    // Update confidence bar
    const confidenceFill = document.getElementById('safetyConfidenceFill');
    const confidenceText = document.getElementById('safetyConfidenceText');
    
    setTimeout(() => {
        confidenceFill.style.width = `${confidence * 100}%`;
        confidenceText.textContent = `Confidence: ${Math.round(confidence * 100)}%`;
    }, 500);
    
    // Update authority status
    updateAuthorityStatus(safetyMetrics.token_info || {});
    
    // Update liquidity status  
    updateLiquidityStatus(safetyMetrics.liquidity_analysis || {});
}

// Animate score counter
function animateScoreCounter(elementId, targetScore) {
    const element = document.getElementById(elementId);
    let currentScore = 0;
    const increment = targetScore / 60; // 60 frames for 1 second animation
    
    const counter = setInterval(() => {
        currentScore += increment;
        if (currentScore >= targetScore) {
            currentScore = targetScore;
            clearInterval(counter);
        }
        element.textContent = Math.round(currentScore);
    }, 16); // ~60fps
}

// Update authority status indicator
function updateAuthorityStatus(tokenInfo) {
    const statusEl = document.getElementById('authorityStatus');
    const valueEl = statusEl.querySelector('.status-value');
    const iconEl = statusEl.querySelector('.status-icon');
    
    if (tokenInfo.is_mutable === false) {
        valueEl.textContent = 'Renounced';
        valueEl.style.color = '#51cf66';
        iconEl.textContent = '‚úÖ';
    } else {
        valueEl.textContent = 'Active';
        valueEl.style.color = '#ff6b6b';
        iconEl.textContent = '‚ö†Ô∏è';
    }
}

// Update liquidity status indicator
function updateLiquidityStatus(liquidityAnalysis) {
    const statusEl = document.getElementById('liquidityStatus');
    const valueEl = statusEl.querySelector('.status-value');
    
    const liquidity = liquidityAnalysis.liquidity_usd || 0;
    const ratio = liquidityAnalysis.liquidity_ratio || 0;
    
    if (ratio > 5) {
        valueEl.textContent = 'Strong';
        valueEl.style.color = '#51cf66';
    } else if (ratio > 2) {
        valueEl.textContent = 'Medium';
        valueEl.style.color = '#ffd93d';
    } else {
        valueEl.textContent = 'Weak';
        valueEl.style.color = '#ff6b6b';
    }
}

// Update Grok Intelligence panel
function updateGrokIntelligence(grokAnalysis) {
    const panel = document.getElementById('grokIntelligencePanel');
    const content = document.getElementById('grokAnalysisContent');
    const verdict = document.getElementById('grokVerdict');
    
    if (!grokAnalysis || !grokAnalysis.available) {
        panel.style.display = 'none';
        return;
    }
    
    const parsedAnalysis = grokAnalysis.parsed_analysis || {};
    const verdictText = parsedAnalysis.verdict || 'CAUTION_ADVISED';
    
    verdict.textContent = verdictText.replace(/_/g, ' ');
    verdict.className = `grok-verdict ${verdictText.toLowerCase()}`;
    
    // Display community intelligence
    content.innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
            <div>
                <h4 style="color: #51cf66; margin-bottom: 10px;">‚úÖ Positive Signals</h4>
                ${(parsedAnalysis.positive_community_sentiment || []).map(signal => 
                    `<p style="color: #ccc; margin-bottom: 8px;">‚Ä¢ ${signal}</p>`
                ).join('') || '<p style="color: #888;">No specific positive signals found</p>'}
            </div>
            <div>
                <h4 style="color: #ff6b6b; margin-bottom: 10px;">‚ö†Ô∏è Risk Signals</h4>
                ${(parsedAnalysis.possible_community_risks || []).map(risk => 
                    `<p style="color: #ccc; margin-bottom: 8px;">‚Ä¢ ${risk}</p>`
                ).join('') || '<p style="color: #888;">No specific risk signals found</p>'}
            </div>
        </div>
        <div style="margin-top: 15px; padding: 15px; background: rgba(108, 92, 231, 0.1); border-radius: 8px;">
            <p style="color: #a29bfe;"><strong>Revolutionary Insight:</strong> ${parsedAnalysis.revolutionary_insight || 'Analysis in progress...'}</p>
        </div>
    `;
    
    panel.style.display = 'block';
}

// Update risk vectors grid
function updateRiskVectors(riskVectors) {
    const grid = document.getElementById('riskVectorsGrid');
    
    if (!riskVectors || riskVectors.length === 0) {
        grid.innerHTML = `
            <div class="risk-vector-card low">
                <h4>‚úÖ No Critical Risk Vectors Detected</h4>
                <p>Revolutionary Galaxy Brain analysis found no major risk patterns in this token.</p>
            </div>
        `;
        return;
    }
    
    grid.innerHTML = riskVectors.map(vector => `
        <div class="risk-vector-card ${vector.severity.toLowerCase()}">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4>${getSeverityIcon(vector.severity)} ${vector.risk_type}</h4>
                <span style="color: ${getSeverityColor(vector.severity)}; font-weight: bold;">
                    ${vector.severity}
                </span>
            </div>
            <p style="color: #ccc; margin-bottom: 15px;">${vector.impact}</p>
            <div style="background: rgba(255, 255, 255, 0.1); padding: 12px; border-radius: 8px;">
                <strong>Mitigation:</strong> ${vector.mitigation}
            </div>
        </div>
    `).join('');
}

// Update advanced safety metrics
function updateAdvancedSafetyMetrics(rugAnalysis) {
    const grid = document.getElementById('safetyMetricsGrid');
    
    const tokenInfo = rugAnalysis.token_info || {};
    const holderAnalysis = rugAnalysis.holder_analysis || {};
    const liquidityAnalysis = rugAnalysis.liquidity_analysis || {};
    const suspiciousActivity = rugAnalysis.suspicious_activity || {};
    const bundleDetection = rugAnalysis.bundle_detection || {};
    
    const metrics = [
        {
            label: 'Market Cap',
            value: formatCurrency(tokenInfo.market_cap || 0),
            subtitle: 'Total Value'
        },
        {
            label: 'Liquidity',
            value: formatCurrency(tokenInfo.liquidity || 0),
            subtitle: `${(liquidityAnalysis.liquidity_ratio || 0).toFixed(1)}% of MC`
        },
        {
            label: 'Token Age',
            value: Math.floor(tokenInfo.age_days || 0),
            subtitle: 'Days Old'
        },
        {
            label: 'Top Holder',
            value: `${(holderAnalysis.top_1_percent || 0).toFixed(1)}%`,
            subtitle: 'Concentration Risk'
        },
        {
            label: 'Wash Trading',
            value: `${(suspiciousActivity.wash_trading_score || 0).toFixed(0)}%`,
            subtitle: 'Manipulation Risk'
        },
        {
            label: 'Bundle Risk',
            value: `${(bundleDetection.bundled_percentage || 0).toFixed(1)}%`,
            subtitle: `${bundleDetection.clusters_found || 0} Clusters`
        },
        {
            label: 'Transaction Health',
            value: `${(suspiciousActivity.transaction_health_score || 50).toFixed(0)}%`,
            subtitle: 'Quality Score'
        },
        {
            label: 'Authorities',
            value: tokenInfo.is_mutable ? 'üî¥ Active' : '‚úÖ Renounced',
            subtitle: 'Mint/Freeze Status'
        }
    ];
    
    grid.innerHTML = metrics.map(metric => `
        <div class="metric-card">
            <div class="metric-label">${metric.label}</div>
            <div class="metric-value">${metric.value}</div>
            <div class="metric-subtitle">${metric.subtitle}</div>
        </div>
    `).join('');
}

// Update safety charts
function updateSafetyCharts(rugAnalysis) {
    // Destroy existing charts
    [revolutionaryRiskChart, holderDistributionChart, transactionHealthChart, bundleDetectionChart].forEach(chart => {
        if (chart) chart.destroy();
    });
    
    setTimeout(() => {
        createRevolutionaryRiskChart(rugAnalysis);
        createHolderDistributionChart(rugAnalysis.holder_analysis || {});
        createTransactionHealthChart(rugAnalysis.suspicious_activity || {});
        createBundleDetectionChart(rugAnalysis.bundle_detection || {});
    }, 100);
}

// Create revolutionary risk chart
function createRevolutionaryRiskChart(rugAnalysis) {
    const canvas = document.getElementById('revolutionaryRiskChart');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const riskVectors = rugAnalysis.risk_vectors || [];
    
    let labels = [];
    let data = [];
    let colors = [];
    
    if (riskVectors.length > 0) {
        labels = riskVectors.map(v => v.risk_type);
        data = riskVectors.map(v => {
            const severityScores = { 'CRITICAL': 90, 'HIGH': 70, 'MEDIUM': 50, 'LOW': 30 };
            return severityScores[v.severity] || 25;
        });
        colors = riskVectors.map(v => getSeverityColor(v.severity));
    } else {
        labels = ['No Major Risks'];
        data = [10];
        colors = ['#51cf66'];
    }
    
    revolutionaryRiskChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: data,
                backgroundColor: colors,
                borderWidth: 2,
                borderColor: '#1a1a1a'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        color: '#fff',
                        padding: 10,
                        font: { size: 11 }
                    }
                }
            }
        }
    });
    
    document.getElementById('revolutionaryRiskValue').textContent = 
        riskVectors.length > 0 ? `${riskVectors.length} risk factors detected` : 'No major risks detected';
}

// Create holder distribution chart
function createHolderDistributionChart(holderData) {
    const canvas = document.getElementById('holderDistributionChart');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    const top1 = holderData.top_1_percent || 0;
    const top5 = (holderData.top_5_percent || 0) - top1;
    const top10 = (holderData.top_10_percent || 0) - (holderData.top_5_percent || 0);
    const others = 100 - (holderData.top_10_percent || 0);
    
    holderDistributionChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: ['Top 1 Holder', 'Top 2-5 Holders', 'Top 6-10 Holders', 'Others'],
            datasets: [{
                data: [top1, top5, top10, others],
                backgroundColor: ['#ff3838', '#ff6b6b', '#ffd93d', '#51cf66'],
                borderWidth: 2,
                borderColor: '#1a1a1a'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        color: '#fff',
                        padding: 10,
                        font: { size: 11 }
                    }
                }
            }
        }
    });
    
    document.getElementById('holderRiskValue').textContent = 
        top1 > 15 ? 'High concentration risk' : top1 > 8 ? 'Medium risk' : 'Healthy distribution';
}

// Create transaction health chart
function createTransactionHealthChart(suspiciousData) {
    const canvas = document.getElementById('transactionHealthChart');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    const healthScore = suspiciousData.transaction_health_score || 50;
    const washScore = suspiciousData.wash_trading_score || 0;
    const organicScore = 100 - washScore;
    
    transactionHealthChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Health Score', 'Organic Activity', 'Wash Risk'],
            datasets: [{
                label: 'Score %',
                data: [healthScore, organicScore, washScore],
                backgroundColor: [
                    healthScore > 70 ? '#51cf66' : healthScore > 40 ? '#ffd93d' : '#ff6b6b',
                    organicScore > 70 ? '#51cf66' : organicScore > 40 ? '#ffd93d' : '#ff6b6b',
                    washScore < 30 ? '#51cf66' : washScore < 60 ? '#ffd93d' : '#ff6b6b'
                ],
                borderWidth: 1,
                borderColor: '#1a1a1a'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: { color: '#fff', font: { size: 10 } },
                    grid: { color: '#333' }
                },
                x: {
                    ticks: { color: '#fff', font: { size: 10 } },
                    grid: { color: '#333' }
                }
            },
            plugins: {
                legend: { display: false }
            }
        }
    });
    
    document.getElementById('transactionHealthValue').textContent = `${healthScore}% healthy transactions`;
}

// Create bundle detection chart
function createBundleDetectionChart(bundleData) {
    const canvas = document.getElementById('bundleDetectionChart');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    const clustersFound = bundleData.clusters_found || 0;
    const bundledPercentage = bundleData.bundled_percentage || 0;
    const organicPercentage = 100 - bundledPercentage;
    
    bundleDetectionChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: ['Organic Holdings', 'Bundled Holdings'],
            datasets: [{
                data: [organicPercentage, bundledPercentage],
                backgroundColor: ['#51cf66', bundledPercentage > 50 ? '#ff3838' : bundledPercentage > 20 ? '#ffd93d' : '#ff6b6b'],
                borderWidth: 2,
                borderColor: '#1a1a1a'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        color: '#fff',
                        padding: 10,
                        font: { size: 11 }
                    }
                }
            }
        }
    });
    
    document.getElementById('bundleDetectionValue').textContent = 
        clustersFound > 0 ? `${clustersFound} clusters detected` : 'No bundle clusters detected';
}

// Update detailed safety tabs
function updateDetailedSafetyTabs(rugAnalysis) {
    updateHoldersSafetyTab(rugAnalysis.holder_analysis || {});
    updateTransactionsSafetyTab(rugAnalysis.transaction_analysis || {}, rugAnalysis.suspicious_activity || {});
    updateBundlesSafetyTab(rugAnalysis.bundle_detection || {});
    updateLiquiditySafetyTab(rugAnalysis.liquidity_analysis || {});
    updateAuthoritySafetyTab(rugAnalysis.token_info || {});
}

// Safety tab functions
function updateHoldersSafetyTab(holderData) {
    const container = document.getElementById('holdersSafetyAnalysis');
    const holders = holderData.top_holders || [];
    
    container.innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
            <div class="metric-card">
                <div class="metric-label">Top 1 Holder</div>
                <div class="metric-value">${(holderData.top_1_percent || 0).toFixed(1)}%</div>
                <div class="metric-subtitle">Concentration risk</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Top 5 Holders</div>
                <div class="metric-value">${(holderData.top_5_percent || 0).toFixed(1)}%</div>
                <div class="metric-subtitle">Combined ownership</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Top 10 Holders</div>
                <div class="metric-value">${(holderData.top_10_percent || 0).toFixed(1)}%</div>
                <div class="metric-subtitle">Total concentration</div>
            </div>
        </div>
        
        ${holders.length > 0 ? `
        <h4 style="margin-bottom: 15px;">üêã Top Holders List</h4>
        <div style="background: rgba(0, 0, 0, 0.3); border-radius: 10px; padding: 15px;">
            ${holders.map(holder => `
                <div style="display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #333;">
                    <span style="font-family: monospace;">#${holder.rank} ${formatAddress(holder.address)}</span>
                    <span style="font-weight: bold; color: ${holder.percentage > 15 ? '#ff3838' : holder.percentage > 8 ? '#ffd93d' : '#51cf66'}">
                        ${holder.percentage.toFixed(2)}%
                    </span>
                </div>
            `).join('')}
        </div>
        ` : '<p style="color: #888; text-align: center;">No detailed holder data available</p>'}
    `;
}

function updateTransactionsSafetyTab(transactionData, suspiciousData) {
    const container = document.getElementById('transactionsSafetyAnalysis');
    
    container.innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
            <div class="metric-card">
                <div class="metric-label">Health Score</div>
                <div class="metric-value">${(suspiciousData.transaction_health_score || 50).toFixed(0)}%</div>
                <div class="metric-subtitle">Transaction quality</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Wash Trading</div>
                <div class="metric-value">${(suspiciousData.wash_trading_score || 0).toFixed(1)}%</div>
                <div class="metric-subtitle">Manipulation risk</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Insider Activity</div>
                <div class="metric-value">${(suspiciousData.insider_activity_score || 0).toFixed(1)}%</div>
                <div class="metric-subtitle">Coordinated trading</div>
            </div>
        </div>
        
        ${suspiciousData.suspicious_patterns && suspiciousData.suspicious_patterns.length > 0 ? `
        <div style="background: rgba(255, 217, 61, 0.1); padding: 20px; border-radius: 10px; border: 1px solid #ffd93d; margin-bottom: 15px;">
            <h4 style="color: #ffd93d; margin-bottom: 15px;">‚ö†Ô∏è Suspicious Patterns Detected</h4>
            ${suspiciousData.suspicious_patterns.map(pattern => `<p>‚Ä¢ ${pattern}</p>`).join('')}
        </div>
        ` : ''}
        
        ${suspiciousData.farming_indicators && suspiciousData.farming_indicators.length > 0 ? `
        <div style="background: rgba(255, 107, 107, 0.1); padding: 20px; border-radius: 10px; border: 1px solid #ff6b6b;">
            <h4 style="color: #ff6b6b; margin-bottom: 15px;">üö® Farming Indicators</h4>
            ${suspiciousData.farming_indicators.map(indicator => `<p>‚Ä¢ ${indicator}</p>`).join('')}
        </div>
        ` : '<p style="color: #51cf66; text-align: center;">‚úÖ No suspicious transaction patterns detected</p>'}
    `;
}

function updateBundlesSafetyTab(bundleData) {
    const container = document.getElementById('bundlesSafetyAnalysis');
    const clusters = bundleData.clusters || [];
    
    container.innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
            <div class="metric-card">
                <div class="metric-label">Clusters Found</div>
                <div class="metric-value">${bundleData.clusters_found || 0}</div>
                <div class="metric-subtitle">Bundle groups</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">High Risk</div>
                <div class="metric-value">${bundleData.high_risk_clusters || 0}</div>
                <div class="metric-subtitle">Dangerous clusters</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Bundled %</div>
                <div class="metric-value">${(bundleData.bundled_percentage || 0).toFixed(1)}%</div>
                <div class="metric-subtitle">Of total supply</div>
            </div>
        </div>
        
        ${clusters.length > 0 ? `
        <h4 style="margin-bottom: 15px;">üï∑Ô∏è Detected Clusters</h4>
        ${clusters.map(cluster => `
            <div style="background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; padding: 15px; margin: 10px 0; border-radius: 5px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <strong>${cluster.cluster_id}</strong>
                    <span style="color: ${cluster.risk_score > 70 ? '#ff3838' : cluster.risk_score > 40 ? '#ffd93d' : '#51cf66'}">
                        Risk: ${cluster.risk_score}%
                    </span>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; font-size: 0.9rem; color: #ccc;">
                    <div>Wallets: ${cluster.wallet_count}</div>
                    <div>Holdings: ${cluster.total_percentage.toFixed(1)}%</div>
                    <div>Pattern: ${cluster.creation_pattern}</div>
                </div>
            </div>
        `).join('')}
        ` : '<p style="color: #51cf66; text-align: center;">‚úÖ No bundle clusters detected - this is good!</p>'}
    `;
}

function updateLiquiditySafetyTab(liquidityData) {
    const container = document.getElementById('liquiditySafetyAnalysis');
    
    container.innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
            <div class="metric-card">
                <div class="metric-label">Liquidity USD</div>
                <div class="metric-value">${formatCurrency(liquidityData.liquidity_usd || 0)}</div>
                <div class="metric-subtitle">Available liquidity</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Liquidity Ratio</div>
                <div class="metric-value">${(liquidityData.liquidity_ratio || 0).toFixed(1)}%</div>
                <div class="metric-subtitle">Of market cap</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Volume/Liquidity</div>
                <div class="metric-value">${(liquidityData.volume_to_liquidity || 0).toFixed(1)}x</div>
                <div class="metric-subtitle">Trading intensity</div>
            </div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
            <div style="background: rgba(255, 217, 61, 0.1); padding: 20px; border-radius: 10px; border: 1px solid #ffd93d;">
                <h4 style="color: #ffd93d; margin-bottom: 15px;">üìä Slippage Estimates</h4>
                <div style="display: grid; gap: 10px;">
                    <div style="display: flex; justify-content: space-between;">
                        <span>$1K Trade:</span>
                        <span style="font-weight: bold;">${(liquidityData.slippage_1k || 0).toFixed(1)}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>$10K Trade:</span>
                        <span style="font-weight: bold;">${(liquidityData.slippage_10k || 0).toFixed(1)}%</span>
                    </div>
                </div>
            </div>
            
            <div style="background: rgba(108, 92, 231, 0.1); padding: 20px; border-radius: 10px; border: 1px solid #6c5ce7;">
                <h4 style="color: #6c5ce7; margin-bottom: 15px;">üîí Liquidity Lock</h4>
                <div style="display: grid; gap: 10px;">
                    <div style="display: flex; justify-content: space-between;">
                        <span>Locked:</span>
                        <span style="font-weight: bold; color: ${liquidityData.is_locked ? '#51cf66' : '#ff6b6b'}">
                            ${liquidityData.is_locked ? 'Yes' : 'No'}
                        </span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span>Duration:</span>
                        <span style="font-weight: bold;">${liquidityData.lock_duration || 'N/A'}</span>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function updateAuthoritySafetyTab(tokenInfo) {
    const container = document.getElementById('authoritySafetyAnalysis');
    
    container.innerHTML = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
            <div class="metric-card">
                <div class="metric-label">Mint Authority</div>
                <div class="metric-value" style="color: ${tokenInfo.mint_authority ? '#ff6b6b' : '#51cf66'}">
                    ${tokenInfo.mint_authority ? 'Active' : 'Renounced'}
                </div>
                <div class="metric-subtitle">Can create new tokens</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Freeze Authority</div>
                <div class="metric-value" style="color: ${tokenInfo.freeze_authority ? '#ff6b6b' : '#51cf66'}">
                    ${tokenInfo.freeze_authority ? 'Active' : 'Renounced'}
                </div>
                <div class="metric-subtitle">Can freeze accounts</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Mutable</div>
                <div class="metric-value" style="color: ${tokenInfo.is_mutable ? '#ff6b6b' : '#51cf66'}">
                    ${tokenInfo.is_mutable ? 'Yes' : 'No'}
                </div>
                <div class="metric-subtitle">Can be modified</div>
            </div>
        </div>
        
        <div style="background: rgba(${tokenInfo.is_mutable ? '255, 107, 107' : '81, 207, 102'}, 0.1); padding: 20px; border-radius: 10px; border: 1px solid ${tokenInfo.is_mutable ? '#ff6b6b' : '#51cf66'};">
            <h4 style="color: ${tokenInfo.is_mutable ? '#ff6b6b' : '#51cf66'}; margin-bottom: 15px;">
                ${tokenInfo.is_mutable ? '‚ö†Ô∏è Authority Risk Assessment' : '‚úÖ Authority Status'}
            </h4>
            <p style="color: #ccc;">
                ${tokenInfo.is_mutable 
                    ? 'This token has active authorities that could pose risks. The token creator can still mint new tokens or freeze accounts.' 
                    : 'All authorities have been renounced. The token cannot be modified, minted, or frozen by the creator.'}
            </p>
        </div>
    `;
}

// Global variable for history popup
let historyPopupOpen = false;

// Toggle history popup
function toggleHistory() {
    const historyPopup = document.getElementById('historyPopup');
    const historyTrigger = document.getElementById('historyTrigger');
    
    historyPopupOpen = !historyPopupOpen;
    
    if (historyPopupOpen) {
        historyPopup.classList.add('active');
        historyTrigger.style.transform = 'scale(0.9)';
        updateTokenHistoryDisplay();
    } else {
        historyPopup.classList.remove('active');
        historyTrigger.style.transform = 'scale(1)';
    }
}

// Update history badge without opening popup
function updateHistoryBadge() {
    const countBadge = document.getElementById('historyCountBadge');
    const trigger = document.getElementById('historyTrigger');
    const subtitle = document.getElementById('historySubtitle');
    const count = tokenHistory.length;
    
    countBadge.textContent = count;
    
    if (count > 0) {
        countBadge.classList.add('show');
        trigger.classList.add('has-history');
        if (subtitle) {
            subtitle.textContent = `${count} token${count === 1 ? '' : 's'} analyzed`;
        }
    } else {
        countBadge.classList.remove('show');
        trigger.classList.remove('has-history');
        if (subtitle) {
            subtitle.textContent = 'No tokens analyzed';
        }
    }
}

// Tab switching function for safety analysis
function showSafetyTab(tabName) {
    // Hide all safety tab contents
    document.querySelectorAll('#safetyAnalysisDashboard .tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // Remove active class from all safety tab buttons
    document.querySelectorAll('#safetyAnalysisDashboard .tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Show selected tab
    document.getElementById(`${tabName}-safety-tab`).classList.add('active');
    
    // Add active class to clicked button
    event.target.classList.add('active');
}

// Utility functions
function getSeverityIcon(severity) {
    const icons = {
        'CRITICAL': 'üö®',
        'HIGH': '‚ö†Ô∏è',
        'MEDIUM': 'üü°',
        'LOW': 'üü¢'
    };
    return icons[severity] || '‚ö™';
}

function getSeverityColor(severity) {
    const colors = {
        'CRITICAL': '#ff3838',
        'HIGH': '#ff6b6b',
        'MEDIUM': '#ffd93d',
        'LOW': '#51cf66'
    };
    return colors[severity] || '#888';
}

function formatCurrency(num) {
    if (num === null || num === undefined || isNaN(num)) return '$0';
    const numValue = parseFloat(num);
    if (numValue >= 1e9) return '$' + (numValue / 1e9).toFixed(2) + 'B';
    if (numValue >= 1e6) return '$' + (numValue / 1e6).toFixed(2) + 'M';
    if (numValue >= 1e3) return '$' + (numValue / 1e3).toFixed(1) + 'K';
    return '$' + numValue.toFixed(2);
}

function formatAddress(address) {
    if (!address) return '';
    return address.slice(0, 8) + '...' + address.slice(-6);
}
</script>
<div class="floating-chat-widget">
    <div class="chat-trigger" id="chatTrigger" onclick="toggleChat()">
        <div class="chat-icon">üí¨</div>
        <div class="pulse-ring"></div>
    </div>
    
    <div class="chat-popup" id="chatPopup">
        <div class="chat-popup-header">
            <div class="chat-title">
                <span>ü§ñ AI Assistant</span>
                <span class="chat-status" id="chatStatus">Ready</span>
            </div>
            <button class="chat-close" onclick="toggleChat()">√ó</button>
        </div>
        
        <div class="chat-popup-messages" id="chatPopupMessages">
            <div class="chat-message assistant">
                üëã Hi! Analyze a token first, then I can chat about it with live market context and search intelligence!
            </div>
        </div>
        
        <div class="chat-popup-input">
            <input type="text" class="chat-input-popup" id="chatInputPopup" placeholder="Ask about the analyzed token..." disabled>
            <button class="chat-send-popup" id="chatSendPopup" onclick="sendChatMessagePopup()" disabled>
                <span>üöÄ</span>
            </button>
        </div>
    </div>
</div>
<!-- Floating History Widget -->
<div class="floating-history-widget">
    <div class="history-trigger" id="historyTrigger" onclick="toggleHistory()">
        <div class="history-icon">üìä</div>
        <div class="history-pulse-ring"></div>
        <div class="history-count-badge" id="historyCountBadge">0</div>
    </div>
    
    <div class="history-popup" id="historyPopup">
        <div class="history-popup-header">
            <div class="history-title">
                <span>üìä Token History</span>
                <div class="history-subtitle" id="historySubtitle">No tokens analyzed</div>
            </div>
            <div class="history-actions">
                <button class="history-clear-btn" onclick="clearTokenHistory()" title="Clear History">
                    üóëÔ∏è Clear
                </button>
                <button class="history-close" onclick="toggleHistory()">√ó</button>
            </div>
        </div>
        
        <div class="history-popup-content" id="historyPopupContent">
            <div class="popup-history-empty">
                <div class="empty-icon">üìà</div>
                <h3>No Token History</h3>
                <p>Analyze tokens to build your history and quickly access previous analyses.</p>
            </div>
        </div>
    </div>
</div>
</body>
</html>